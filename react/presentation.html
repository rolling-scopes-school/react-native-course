<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>rolling-scopes-school/react-native-course - React module</title>
    <meta
      name="description"
      content="rolling-scopes-school/react-native-course - name module"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../reveal-js/dist/reset.css" />
    <link rel="stylesheet" href="../reveal-js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="../reveal-js/dist/theme/white.css"
      id="theme"
    />
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../reveal-js/plugin/highlight/monokai.css" />
    <link rel="stylesheet" href="../reveal-js/common.css" />
    <style class="jsStyle"></style>
  </head>
  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <!-- 1-ST SLIDE -->
        <section class="presentation-name-slide">
          <h4>React</h4>

          <aside class="notes">
            <strong>ATTENSION SUPER IMPORTANT LECTION</strong>
            <br /><br />
            React is one of the most popular libraries for building user
            interfaces, and companies like Twitter, Netflix, Airbnb, and PayPal
            use it <strong>to power</strong> their frontend experiences.
            <br /><br />
            React is really awesome, and having a good command of the
            fundamentals will help you build projects of all sizes.
            <br /><br />
            Today we're <strong>going to get hands-on experience</strong> with
            React's core concepts.
          </aside>
        </section>

        <!-- AGENDA -->
        <section class="agenda-slide">
          <h4 class="slide-name">agenda</h4>
          <ul>
            <li class="fragment">
              React foundation
              <ul>
                <li class="fragment">What is it React?</li>
                <li class="fragment">JSX</li>
                <li class="fragment">Components and props</li>
              </ul>
            </li>
            <li class="fragment">React lifecycle</li>
            <li class="fragment">
              React hooks and HOCs
              <ul>
                <li>Motivation</li>
                <li>Basic hooks</li>
                <li>Hook rules</li>
                <li>Custom hooks</li>
                <li>Hoc</li>
              </ul>
            </li>
            <li class="fragment">Controlled/Uncontrolled components</li>
            <li class="fragment">Reconciliation</li>
            <li class="fragment">Fiber</li>
          </ul>

          <aside class="notes">
            On this slide you can see today's agenda.
            <br /><br />
            We will start with..
            <br /><br />
            Next…
            <br /><br />
            And the last one ..
          </aside>
        </section>

        <!-- FRAMEWORK -->
        <section class="picture-slide">
          <h4 class="slide-name">framework</h4>
          <img src="assets/images/Framework_slide.png" alt="Framework_slide" />

          <aside class="notes">
            Front-end development has continued to improve over the years. From
            simple static pages to now complex single-page applications, our
            tools are getting more and more powerful. Now, the
            <strong>three front-end frameworks</strong> rule the front-end
            development. <br /><br />
            When developing web pages IN THE PAST,
            <strong>
              we mainly operated the DOM through the DOM API provided by the
              browser</strong
            >. However, the DOM API is huge, and there are compatibility
            problems in different browsers. In order to simplify dom operations
            and be compatible with different browsers,
            <strong>jQuery</strong> became popular. At that time, jQuery could
            be said to be a must-learn technology for front-end developers.
            <br /><br />
            Then when developing web pages, we found that what a web page needs
            to do is to get the data from the server first, and then update the
            DOM according to the data. And this process is fixed. In order to
            simplify DOM manipulation,
            <strong>people invented the MVVM framework</strong> to automatically
            map data changes to DOM updates without the need to manually
            manipulate the DOM. This is what the front-end frameworks
            <strong>Angular, React, Vue</strong> do.
          </aside>
        </section>

        <!-- WHAT IS IT REACT? -->
        <section class="bullets-and-picture-slide">
          <h4 class="slide-name">what is it react?</h4>
          <div>
            <img src="assets/images/react.png" alt="react" />
            <ul>
              <li>Library</li>
              <li>Facebook</li>
              <li>Open-sourced</li>
              <li>React Native</li>
              <li>Thousands of stars on GitHub</li>
              <li>Amazing products</li>
            </ul>
          </div>

          <aside class="notes">
            React is a JavaScript <strong>library</strong> that you can use to
            create user interfaces. <br /><br />
            It was created at <strong>Facebook and open-sourced</strong> in
            March of 2013. <br /><br />
            Since then, React has
            <strong>expanded beyond the web with React Native</strong>, a tool
            that allows you to create native mobile applications using React.
            <br /><br />
            React is an increasingly popular library with
            <strong>tens of thousands of stars</strong> on GitHub and used in
            production by huge companies. <br /><br />
            But the point of using React is not just because it's popular, but
            because its component architecture makes
            <strong>it faster and easier</strong> to build amazing products.
          </aside>
        </section>

        <!-- CODE SANDBOX -->
        <section>
          <section class="picture-with-description-slide">
            <h4 class="slide-name">code sandbox - step 1</h4>
            <img src="assets/images/code_sandbox_1.png" alt="code_sandbox_1" />
            <p>
              Open
              <a href="https://codesandbox.io/" target="_blank"
                >https://codesandbox.io/</a
              >, click "Create" button and choose React template
            </p>
            <aside class="notes">
              The quickest way to get started with a React project is to use
              CodeSandbox at codesandbox.io.
              <br /><br />
              Here if you click on the Create button then on the next page,
              there are a ton of different templates that you can use to get
              started with many different web development projects.
              <br /><br />
              The first of them, probably the most popular, used with
              CodeSandbox is React. So simply clicking on this will allow you to
              interact with some code directly in the browser, and we can see
              them render right away in the preview window.
            </aside>
          </section>

          <section class="picture-with-description-slide">
            <h4 class="slide-name">code sandbox - step 2</h4>
            <img src="assets/images/code_sandbox_2.png" alt="code_sandbox_2" />
            <p>Your project is created</p>
          </section>

          <section class="text-and-conding-slide">
            <h4 class="slide-name">code sandbox - step 3</h4>
            <p class="fragment" data-fragment-index="1">
              Let's change index.js file to avoid issue with 2 renders. Please
              paste code bellow to the index.js file.
            </p>
            <pre class="fragment" data-fragment-index="2">
                <code data-trim data-line-numbers>
                  import ReactDOM from "react-dom";

                  import App from "./App";

                  const rootElement = document.getElementById("root");
                  ReactDOM.render(&lt;App />, rootElement);
                </code>
              </pre>
          </section>

          <section class="picture-with-description-slide">
            <h4 class="slide-name">code sandbox - step 4</h4>
            <img src="assets/images/code_sandbox_3.gif" alt="code_sandbox_3" />
            <p>You are ready to GO</p>
            <aside class="notes">
              So if you would rather use CodeSandbox instead of setting up your
              own project locally, that's absolutely fine
              <br /><br />
              To summarize, this SANDBOX is only recommended for using during
              education, for real project please use IDE.
            </aside>
          </section>
        </section>

        <!-- JSX -->
        <section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">JSX</h4>
            <div>
              <p>Embedding Expressions</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
const element = <h1>Hello, {name}</h1>;
                </code>
              </pre>
            </div>

            <div>
              <p>Specifying Attributes with JSX</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
const element = <img src={source} />
                </code>
              </pre>
            </div>
            <aside class="notes">
              <strong> JSX it is a syntax extension to JavaScript.</strong
              ><br />
              JSX may remind you of a template language, but it comes with the
              full power of JavaScript.
              <br /><br />
              <strong> Embedding Expressions in JSX</strong><br />
              You can put any valid JavaScript expression inside the curly
              braces in JSX
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">JSX</h4>
            <div>
              <p>JSX Prevents Injection Attacks</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
const element = <h1>{response.potentiallyMaliciousInput}</h1>
                </code>
              </pre>
            </div>
            <div>
              <p>JSX Represents Objects</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
const element = <h1 className="greeting">Hello, world!</h1>;
// ===
const element = React.createElement(
  "h1",
  { className: "greeting" },
  "Hello, world!"
);
                </code>
              </pre>
            </div>
            <aside class="notes">
              <strong> JSX Prevents Injection Attacks</strong><br />
              By default, React DOM escapes any values embedded in JSX before
              rendering them. Thus it ensures that you can never inject anything
              that's not explicitly written in your application. Everything is
              converted to a string before being rendered. This helps prevent
              XSS (cross-site-scripting) attacks.
              <br /><br />
              <strong>JSX Represents Objects</strong><br />
              Babel compiles JSX down to React.createElement() calls. So, two
              rows in example are identical
            </aside>
          </section>
        </section>

        <!-- COMPONENTS AND PROPS -->
        <section class="coding-and-picture-slide">
          <h4 class="slide-name">components and props</h4>
          <div>
            <img
              src="assets/images/components_and_props.png"
              alt="components_and_props"
            />
            <div>
              <div>
                <p>Functional component</p>
                <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}                    
                </code>
              </pre>
              </div>
              <div>
                <p>Class component</p>
                <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {props.name}</h1>;
  }
}       
                </code>
              </pre>
              </div>
            </div>
          </div>
          <aside class="notes">
            <strong>Components</strong> allow you to break down an interface
            into independent pieces that are easy to think of as a composition.
            They can be stacked together and used multiple times.

            <br /><br />
            There are <strong>two ways</strong> to declare components in
            functional and class style. <br /><br />
            The <strong>first example</strong> on the screen shows an example of
            a functional component. This function is a component because it
            <strong>takes data</strong> in a single object
            (“<strong>props</strong>”) as a parameter and
            <strong>returns a React element</strong>. We will call such
            components "<strong>functional</strong>" because they are literally
            functions.

            <br /><br />
            You can also use an <strong>ES6 class</strong> to define the
            component, as shown <strong>in the second example</strong>.

            <br /><br />
            The above two components are equivalent from React's point of view.
          </aside>
        </section>

        <!-- CLASS COMPONENT EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">component example - prepation</h4>
            <div>
              <img
                src="assets/images/class_component_example_0.png"
                alt="class_component_example_0"
              />
              <ol>
                <li>
                  Create folder <strong>components-and-props</strong> inside
                  your <strong>src</strong> folder
                </li>
                <li>
                  Create <strong>index.js</strong> inside
                  <strong>components-and-props</strong> folder
                </li>
                <li>
                  Create <strong>class-counter.js</strong> inside
                  <strong>components-and-props</strong> folder
                </li>
                <li>Start coding your first class component</li>
              </ol>
            </div>
            <aside class="notes">
              Let's try to create two examples of counter component in the
              functional and class components.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">class component example - ClassCounter</h4>
            <p>Let's create ClassCounter component with empty render method</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
              import React from "react";

              class ClassCounter extends React.Component {
                render() {
                  // ...
                }
              }
              
              export default ClassCounter;
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">component example - render method</h4>
            <p>
              And now let's add code to the render method that will display the
              third level title obtained from the properties of this component.
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4-10">
              import React from "react";

              class ClassCounter extends React.Component {
                render() {
                  return (
                    <div>
                      <h3>{this.props.name}</h3>
                    </div>
                  );
                }
              }
              
              export default ClassCounter;
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">class component example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import ClassCounter from "./class-counter";

                export { ClassCounter };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">class component example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="3,8-11">
                import "./styles.css";

                import { ClassCounter } from "./components-and-props";
                
                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class components</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                      </div>
                    &lt;/div>
                  );
                }                
					    </code>
            </pre>
          </section>
          <section class="picture-slide">
            <h4 class="slide-name">class component example - result</h4>
            <img
              src="assets/images/class_component_example.png"
              class="with-border"
              alt="class_component_example"
            />
          </section>
        </section>

        <!-- FUNCTIONAL COMPONENT EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">
              functional component example - FunctionalCounter
            </h4>
            <div>
              <img
                src="assets/images/functional_component_example_0.png"
                alt="functional_component_example_0"
              />
              <ol>
                <li>
                  Create <strong>functional-counter.js</strong> inside
                  <strong>components-and-props</strong> folder
                </li>
                <li>Start coding your first functional component</li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              functional component example - FunctionalCounter
            </h4>
            <p>Let's create FunctionalCounter component</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
              import React from "react";

              const FunctionalCounter = (props) => {
                
                // ...
              };
              
              export default FunctionalCounter;                
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">functional component example - return</h4>
            <p>
              And now let's add code that will display the third level title
              obtained from the properties of this component.
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4-8">
                import React from "react";

                const FunctionalCounter = (props) => {
                  return (
                    <div>
                      <h3>{props.name}</h3>
                    </div>
                  );
                };
                
                export default FunctionalCounter;                                
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">functional component example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="2,4">
                import ClassCounter from "./class-counter";
                import FunctionalCounter from "./functional-counter";

                export { ClassCounter, FunctionalCounter };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">functional component example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="3,12">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";


                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      </div>
                    &lt;/div>
                  );
                }
					    </code>
            </pre>
          </section>
          <section class="picture-slide">
            <h4 class="slide-name">functional component example - result</h4>
            <img
              src="assets/images/functional_component_example.png"
              class="with-border"
              alt="functional_component_example"
            />
            <aside class="notes">
              As you can see, declaring components is very simple and now the
              differences between the two types of components are not that big.
            </aside>
          </section>
        </section>

        <!-- ADDITIONAL MATERIALS -->
        <section class="video-text-slide">
          <h4 class="slide-name">additional materials</h4>
          <div>
            <div>
              <a
                href="https://www.youtube.com/watch?v=x7cQ3mrcKaY"
                target="_blank"
                >React: Rethinking best practices
              </a>
              <iframe
                src="https://www.youtube.com/embed/x7cQ3mrcKaY"
                title="React: Rethinking best practices"
                allowfullscreen
              >
              </iframe>
            </div>
            <div>
              <p>
                Author is a member of the React core team at Facebook and
                Instagram.
              </p>
              <p>
                - the notion of templates;
                <br />
                - re-rendering process;
                <br />
                - lightweight implementation of the DOM and events.
              </p>
            </div>
          </div>
          <aside class="notes">
            Author (Pete) is a member of the React core team at Facebook and
            also the sole engineer on Instagram.com.
            <br /><br />
            He has also designed and implemented the video encode backend
            infrastructure for Facebook and Instagram and computer vision
            infrastructure and general front-end web engineering for Facebook
            photos.
            <br /><br />
            This video will start with a brief introduction to the framework,
            and then dive into three controversial topics:
            <br /><br />
            - Throwing out the notion of templates and building views with
            JavaScript, <br />
            - "re-rendering" your entire application when your data changes,<br />
            - and a lightweight implementation of the DOM and events.<br />
          </aside>
        </section>

        <!-- REACT LIFECYCLE -->
        <section class="picture-slide">
          <h4 class="slide-name">react lifecycle</h4>
          <img src="assets/images/react_lifecycle.png" alt="react_lifecycle" />
          <aside class="notes">
            Each component in React has a lifecycle which you can monitor and
            manipulate during its three main phases.
            <br /><br />
            The three phases are: <strong>Mounting</strong>,
            <strong>Updating</strong>, and <strong>Unmounting</strong>.
          </aside>
        </section>

        <!-- REACT LIFECYCLE METHODS - MOUNTING -->
        <section class="picture-slide">
          <h4 class="slide-name">react lifecycle - mounting</h4>
          <img
            src="assets/images/react_lifecycle_method_mounting.png"
            alt="react_lifecycle_method_mounting"
          />
          <aside class="notes">
            Every component in React goes through a lifecycle of events. I like
            to think of them as going through a cycle of birth, growth, and
            death. <strong>Mounting</strong> - birth of your component.
            <strong>Updating</strong> - growth of your component. And
            <strong>unmounting</strong> - death of your component.
          </aside>
        </section>

        <!-- MOUNTING EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">mounting example</h4>
            <div>
              <img
                src="assets/images/mounting_example.png"
                alt="mounting_example"
              />
              <ol>
                <li>
                  Create folder <strong>lifecycle</strong> inside your
                  <strong>src</strong> folder
                </li>
                <li>
                  Create <strong>index.js</strong> inside
                  <strong>lifecycle</strong> folder
                </li>
                <li>
                  Create <strong>mouning.js</strong> inside
                  <strong>lifecycle</strong> folder
                </li>
                <li>
                  Start coding <strong>MountingComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example - Component</h4>
            <p>Let's create MountingComponent component</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                class MountingComponent extends React.Component {
                
                  render() {
                    // ...
                  }
                }
                
                export default MountingComponent;                
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example - constructor</h4>
            <p>
              Let's add a constructor to our component that will initialize the
              parent class and add a couple of fields to the state object.
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4-11">
                import React from "react";

                class MountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      prevName: this.props.name,
                      isLoading: true,
                      lastName: null
                    };
                  }

                  render() {
                    // ...
                  }
                }
                
                export default MountingComponent;  
					    </code>
            </pre>
            <aside class="notes">
              The <strong>constructor()</strong> method is called
              <strong>before anything else</strong>, when the component is
              initiated, and it is the natural place to set up the
              <strong>initial state</strong> and other initial values.
              <br /><br />
              The constructor() method is called with the props, as arguments,
              and you should always
              <strong>start by calling the super(props)</strong> before anything
              else, this will initiate the parent's constructor method and
              allows the component to inherit methods from its parent
              (React.Component).
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              mounting example - getDerivedStateFromProps
            </h4>
            <p>Next thing that we'll add it is getDerivedStateFromProps.</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="13-23">
                import React from "react";

                class MountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      prevName: this.props.name,
                      isLoading: true,
                      lastName: null
                    };
                  }

                  static getDerivedStateFromProps(props, state) {
                    if (props.name !== state.prevName) {
                      //Change in props
                      return {
                        prevName: props.name,
                        isLoading: true,
                        lastName: null
                      };
                    }
                    return null; // No change to state
                  }

                  render() {
                    // ...
                  }
                }
                
                export default MountingComponent;  
					    </code>
            </pre>
            <aside class="notes">
              getDerivedStateFromProps is invoked right
              <strong>before calling the render method</strong>, both on the
              initial mount and on update stages. It should
              <strong>return an object</strong> to update the state,
              <strong>or null</strong> to update nothing.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example - render</h4>
            <p>
              And now let's implement the render method and add some logic
              related to the loading state.
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="25-35">
                import React from "react";

                class MountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      prevName: this.props.name,
                      isLoading: true,
                      lastName: null
                    };
                  }

                  static getDerivedStateFromProps(props, state) {
                    if (props.name !== state.prevName) {
                      //Change in props
                      return {
                        prevName: props.name,
                        isLoading: true,
                        lastName: null
                      };
                    }
                    return null; // No change to state
                  }

                  render() {
                    const [{ name }, { isLoading, lastName }] = [this.props, this.state];
                
                    if (isLoading) return <p>Loading</p>;
                
                    return (
                      <h3>
                        {name} {lastName}
                      </h3>
                    );
                  }
                }
                
                export default MountingComponent;  
					    </code>
            </pre>
            <aside class="notes">
              render() - The render() method is the most used lifecycle method.
              You will see it in all React classes. This is because
              <strong>render()</strong>is the only required method within a
              class component in React. As the name suggests it handles the
              rendering of your component to the UI. It happens during the
              <strong>mounting</strong> and <strong>updating</strong> of your
              component.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example - componentDidMount</h4>
            <p>The last thing is componentDidMount</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="25-29">
                import React from "react";

                class MountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      prevName: this.props.name,
                      isLoading: true,
                      lastName: null
                    };
                  }

                  static getDerivedStateFromProps(props, state) {
                    if (props.name !== state.prevName) {
                      //Change in props
                      return {
                        prevName: props.name,
                        isLoading: true,
                        lastName: null
                      };
                    }
                    return null; // No change to state
                  }

                  componentDidMount() {
                    setTimeout(() => {
                      this.setState({ isLoading: false, lastName: "LastName" });
                    }, 3000);
                  }

                  render() {
                    const [{ name }, { isLoading, lastName }] = [this.props, this.state];
                
                    if (isLoading) return <p>Loading</p>;
                
                    return (
                      <h3>
                        {name} {lastName}
                      </h3>
                    );
                  }
                }
                
                export default MountingComponent;  
					    </code>
            </pre>
            <aside class="notes">
              componentDidMount() - Now your component has been mounted and
              ready, that's when the next React lifecycle method
              <strong>componentDidMount()</strong>comes in play.
              <br />
              It is called as soon as the component is mounted and ready.
              <br />
              This method is a good place to
              <strong>set up any subscriptions</strong>. If you do that,
              <strong>don't forget to unsubscribe</strong> in
              componentWillUnmount().
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import MountingComponent from "./mouning";

                export { MountingComponent };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">mounting example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4,14-18">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { MountingComponent } from "./lifecycle";

                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      </div>
                      <br /> <br />
                      <div>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                      </div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">mounting example - result</h4>
            <div>
              <iframe data-src="assets/videos/mounting_example.mp4"></iframe>
            </div>
          </section>
        </section>

        <!-- REACT LIFECYCLE METHODS - UPDATING -->
        <section class="picture-slide">
          <h4 class="slide-name">react lifecycle - updating</h4>
          <img
            src="assets/images/react_lifecycle_method_updating.png"
            alt="react_lifecycle_method_updating"
          />
        </section>

        <!-- UPDATING EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">updating example</h4>
            <div>
              <img
                src="assets/images/updating_example.png"
                alt="updating_example"
              />
              <ol>
                <li>
                  Create <strong>updaing.js</strong> inside
                  <strong>lifecycle</strong> folder
                </li>
                <li>
                  Start coding <strong>UpdatingComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example - UpdatingComponent</h4>
            <p>
              Let's create MountingComponent and two arrays in the state to
              store counter values
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  render() {
                    // ...
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example - Counter</h4>
            <p>Now we'll add Counter component</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="33-52|9-30">
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  return (
                    &lt;>
                      &lt;Counter
                        value={this.state.counter1}
                        onClick={() =>
                          this.setState({
                            counter1: [...this.state.counter1, this.state.counter1.length + 1]
                          })
                        }
                        name={"counter 1"}
                      />
                      &lt;Counter
                        value={this.state.counter2}
                        onClick={() =>
                          this.setState({
                            counter2: [...this.state.counter2, this.state.counter2.length + 1]
                          })
                        }
                        name={"counter 2"}
                      />
                    &lt;/>
                  );
                }

                class Counter extends React.Component {
                  // Get box DOM reference
                  buttonRef = React.createRef();

                  render() {
                    console.log(`Rendering ${this.props.name}`);
                    return (
                      <div>
                        <h2>{this.props.name}:</h2>
                        <div>
                          {this.props.value.map((e, index) => (
                            <p key={index}>{e}</p>
                          ))}
                        </div>
                        <button ref={this.buttonRef} onClick={this.props.onClick}>
                          Add
                        </button>
                      </div>
                    );
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example - shouldComponentUpdate</h4>
            <p>Let's add shouldComponentUpdate</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="37-39">
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  return (
                    &lt;>
                      &lt;Counter
                        value={this.state.counter1}
                        onClick={() =>
                          this.setState({
                            counter1: [...this.state.counter1, this.state.counter1.length + 1]
                          })
                        }
                        name={"counter 1"}
                      />
                      &lt;Counter
                        value={this.state.counter2}
                        onClick={() =>
                          this.setState({
                            counter2: [...this.state.counter2, this.state.counter2.length + 1]
                          })
                        }
                        name={"counter 2"}
                      />
                    &lt;/>
                  );
                }

                class Counter extends React.Component {
                  // Get box DOM reference
                  buttonRef = React.createRef();

                  shouldComponentUpdate(nextProps) {
                    return nextProps.value !== this.props.value
                  }

                  render() {
                    console.log(`Rendering ${this.props.name}`);
                    return (
                      <div>
                        <h2>{this.props.name}:</h2>
                        <div>
                          {this.props.value.map((e, index) => (
                            <p key={index}>{e}</p>
                          ))}
                        </div>
                        <button ref={this.buttonRef} onClick={this.props.onClick}>
                          Add
                        </button>
                      </div>
                    );
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              shouldComponentUpdate() - This lifecycle can be handy sometimes
              when you don't want React to render your state or prop changes.
              Anytime setState() is called, the component re-renders by default.
              The shouldComponentUpdate() method is used to let React know if a
              component is not affected by the state and prop changes. Keep in
              mind that this lifecycle method should be sparingly used, and it
              exists only for certain performance optimizations.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              updating example - getSnapshotBeforeUpdate
            </h4>
            <p>Let's add getSnapshotBeforeUpdate</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="41-46">
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  return (
                    &lt;>
                      &lt;Counter
                        value={this.state.counter1}
                        onClick={() =>
                          this.setState({
                            counter1: [...this.state.counter1, this.state.counter1.length + 1]
                          })
                        }
                        name={"counter 1"}
                      />
                      &lt;Counter
                        value={this.state.counter2}
                        onClick={() =>
                          this.setState({
                            counter2: [...this.state.counter2, this.state.counter2.length + 1]
                          })
                        }
                        name={"counter 2"}
                      />
                    &lt;/>
                  );
                }

                class Counter extends React.Component {
                  // Get box DOM reference
                  buttonRef = React.createRef();

                  shouldComponentUpdate(nextProps) {
                    return nextProps.value !== this.props.value
                  }

                  getSnapshotBeforeUpdate() {
                    // Let componentDidUpdate know whether to override the button color or not.
                    return {
                      overrideBoxColor: this.buttonRef.current.offsetTop > 500
                    };
                  }

                  render() {
                    console.log(`Rendering ${this.props.name}`);
                    return (
                      <div>
                        <h2>{this.props.name}:</h2>
                        <div>
                          {this.props.value.map((e, index) => (
                            <p key={index}>{e}</p>
                          ))}
                        </div>
                        <button ref={this.buttonRef} onClick={this.props.onClick}>
                          Add
                        </button>
                      </div>
                    );
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              getSnapshotBeforeUpdate() is invoked right before the most
              recently rendered output is committed to e.g. the DOM. It enables
              your component to capture some information from the DOM (e.g.
              scroll position) before it is potentially changed. Any value
              returned by this lifecycle method will be passed as a parameter to
              componentDidUpdate().
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example - componentDidUpdate</h4>
            <p>Let's add componentDidUpdate</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="48-53">
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  return (
                    &lt;>
                      &lt;Counter
                        value={this.state.counter1}
                        onClick={() =>
                          this.setState({
                            counter1: [...this.state.counter1, this.state.counter1.length + 1]
                          })
                        }
                        name={"counter 1"}
                      />
                      &lt;Counter
                        value={this.state.counter2}
                        onClick={() =>
                          this.setState({
                            counter2: [...this.state.counter2, this.state.counter2.length + 1]
                          })
                        }
                        name={"counter 2"}
                      />
                    &lt;/>
                  );
                }

                class Counter extends React.Component {
                  // Get box DOM reference
                  buttonRef = React.createRef();

                  shouldComponentUpdate(nextProps) {
                    return nextProps.value !== this.props.value
                  }

                  getSnapshotBeforeUpdate() {
                    // Let componentDidUpdate know whether to override the button color or not.
                    return {
                      overrideBoxColor: this.buttonRef.current.offsetTop > 500
                    };
                  }

                  componentDidUpdate(prevProps, prevState, snapshot) {
                    // Override the button ref directly
                    if (snapshot.overrideBoxColor) {
                      this.buttonRef.current.style.backgroundColor = "red";
                    }
                  }

                  render() {
                    console.log(`Rendering ${this.props.name}`);
                    return (
                      <div>
                        <h2>{this.props.name}:</h2>
                        <div>
                          {this.props.value.map((e, index) => (
                            <p key={index}>{e}</p>
                          ))}
                        </div>
                        <button ref={this.buttonRef} onClick={this.props.onClick}>
                          Add
                        </button>
                      </div>
                    );
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              componentDidUpdate() - This lifecycle method is invoked as soon as
              the updating happens. The most common use case for the
              componentDidUpdate() method is updating the DOM in response to
              prop or state changes. On the screen you can see typical example
              of usage of this lifecycle method. Notice in this example that we
              are comparing the current props to the previous props. This is to
              check if there has been a change in props from what it currently
              is. In this case, there won't be a need to make the API call if
              the props did not change.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="2,4">
                import MountingComponent from "./mouning";
                import UpdatingComponent from "./updaing";

                export { MountingComponent, UpdatingComponent };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">updating example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4,18">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { MountingComponent, UpdatingComponent } from "./lifecycle";

                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      </div>
                      <br /> <br />
                      <div>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                      </div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">updating example - result</h4>
            <div>
              <iframe data-src="assets/videos/updating_example.mp4"></iframe>
            </div>
          </section>
        </section>

        <!-- REACT LIFECYCLE METHODS - UNMOUNTING -->
        <section class="picture-slide">
          <h4 class="slide-name">react lifecycle - unmounting</h4>
          <img
            src="assets/images/react_lifecycle_method_unmounting.png"
            alt="react_lifecycle_method_unmounting"
          />
        </section>

        <!-- UNMOUNTING EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">unmounting example</h4>
            <div>
              <img
                src="assets/images/unmounting_example.png"
                alt="unmounting_example"
              />
              <ol>
                <li>
                  Create <strong>unmounting.js</strong> inside
                  <strong>lifecycle</strong> folder
                </li>
                <li>
                  Start coding <strong>UnmountingComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">unmounting example - UnmountingComponent</h4>
            <p>Let's create UnmountingComponent and date in the state</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                class UnmountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      date: new Date()
                    };
                  }

                  tick() {
                    this.setState({
                      date: new Date()
                    });
                  }

                  render() {
                    return <p>{this.state.date.toLocaleTimeString()}</p>;
                  }
                }

                export default UnmountingComponent;               
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              unmounting example - componentWillUnmount
            </h4>
            <p>Let's add componentWillUnmount</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="17-25">
                import React from "react";

                class UnmountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      date: new Date()
                    };
                  }

                  tick() {
                    this.setState({
                      date: new Date()
                    });
                  }

                  componentDidMount() {
                    this.timerID = setInterval(() => {
                      this.tick();
                    }, 1000);
                  }
                
                  componentWillUnmount() {
                    clearInterval(this.timerID);
                  }

                  render() {
                    return <p>{this.state.date.toLocaleTimeString()}</p>;
                  }
                }

                export default UnmountingComponent;               
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">unmounting example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="3-5">
                import MountingComponent from "./mouning";
                import UpdatingComponent from "./updaing";
                import UnmountingComponent from "./unmounting";

                export { MountingComponent, UpdatingComponent, UnmountingComponent };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">unmounting example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4-8,23">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";

                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      </div>
                      <br /> <br />
                      <div>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      </div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">unmounting example - result</h4>
            <div>
              <iframe data-src="assets/videos/unmounting_example.mp4"></iframe>
            </div>
          </section>
        </section>

        <!-- HOOKS -->
        <section>
          <section class="bullets-slide">
            <h4 class="slide-name">hooks - motivation</h4>
            <ul>
              <li>It's hard to reuse stateful logic between components</li>
              <li>Complex components become hard to understand</li>
              <li>Classes confuse both people and machines</li>
            </ul>
            <aside class="notes">
              Hooks let us use state and other React features without writing a
              class.
              <br /><br />
              <strong>2 main points about hooks</strong>:<br />
              - There are no plans to remove classes from React.<br />
              - Hooks don't replace your knowledge of React concepts. Instead,
              Hooks provide a more direct API to the React concepts you already
              know props, state, context, refs, and lifecycle.
              <br /><br />
              On the slide you see 3 motivations why hooks were introduced.
              <br /><br />
              First, about sharing the business logic. Yes, with hooks, you can
              extract some component logic from a component so that it can be
              independently tested and reused. Hooks allow you to reuse stateful
              logic without changing the component hierarchy. This makes it easy
              to share hooks between many components or with the community.
              <br /><br />
              About second point. We can easy meet hard to maintain components
              that contains a number of lifecycle methods that often often
              contains a mix of unrelated logic. For example, components might
              perform some data fetching in componentDidMount and the same
              componentDidMount method might also contain some unrelated logic
              that sets up event listeners. Completely unrelated code combined
              in a single method. This makes it too easy to introduce bugs and
              inconsistencies.
              <br /><br />
              And about the last point. In addition to making code reuse and
              code organization more difficult, we've found that classes can be
              a large barrier to learning React. You have to understand how this
              works in JavaScript, which is very different from how it works in
              most languages. You have to remember to bind the event handlers.
              To solve these problems, Hooks let you use more of React's
              features without classes. Conceptually, React components have
              always been closer to functions.
              <br /><br />
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">hooks - basic examples</h4>
            <div>
              <p>State Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  const [state, setState] = useState(initialState);                
                </code>
              </pre>
            </div>
            <div>
              <p>Effect Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  useEffect(didUpdate);                  
                </code>
              </pre>
            </div>
            <div>
              <p>Callback Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  const memoizedCallback = useCallback(() => {
                    doSomething(a, b);
                  }, [a, b]);                                  
                </code>
              </pre>
            </div>
            <aside class="notes">
              Ok, let's start with the first one - state hook. It is the
              simplest one and post popular one. It returns a stateful value,
              and a function to update it. During the initial render, the
              returned state (state) is the same as the value passed as the
              first argument (initialState). The setState function is used to
              update the state. It accepts a new state value and starts a
              re-render of the component.
              <br /><br />
              Next hook is useEffect. The Effect Hook lets you perform side
              effects in function components Data fetching, setting up a
              subscription, and manually changing the DOM in React components
              are all examples of side effects. By using this Hook, you tell
              React that your component needs to do something after render. If
              your effect returns a function, React will run it when it is time
              to clean up. Also, you can tell React to skip applying an effect
              if certain values haven't changed between re-renders. To do so,
              pass an array as an optional second argument to useEffect.

              <br /><br />
              The React useCallback Hook returns a memoized callback function.
              Think of memoization as caching a value so that it does not need
              to be recalculated. This allows us to isolate resource intensive
              functions so that they will not automatically run on every render.
              The useCallback Hook only runs when one of its dependencies
              update. This can improve performance.
            </aside>
          </section>
          <section class="coding-and-picture-slide">
            <h4 class="slide-name">hooks - basic examples</h4>
            <div>
              <img src="assets/images/hooks_context.png" alt="hooks_context" />
              <div>
                <div>
                  <p>Context Hook</p>
                  <pre data-id="code-animation">
                  <code class="js" data-trim data-line-numbers>
                    const value = useContext(MyContext);
                  </code>
                </pre>
                </div>
              </div>
            </div>
            <aside class="notes">
              useContext To illustrate the problem that this hook can solve, I
              want you to imagine many nested components. The component at the
              top and bottom of the stack need access to the state. To do this
              without Context, we will need to pass the state as "props" through
              each nested component. This is called "prop drilling". The
              solution is to create context. To create context, you must Import
              createContext and initialize it. Next we'll use the Context
              Provider to wrap the tree of components that need the state
              Context. Now, all components in this tree will have access to the
              user Context. And in order to use the Context in a child
              component, we need to access it using the useContext Hook.
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">hooks - basic examples</h4>
            <div>
              <p>Memo Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  const memoizedValue = useMemo(() => {
                    return computeExpensiveValue(a, b);
                  }, [a, b]);         
                </code>
              </pre>
            </div>
            <div>
              <p>Ref Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  const refContainer = useRef(initialValue);
                </code>
              </pre>
            </div>
            <div>
              <p>Other hooks: https://betterprogramming.pub/</p>
            </div>
            <aside class="notes">
              useMemo - Returns a memoized value. The useMemo Hook only runs
              when one of its dependencies update. This can improve performance.
              <br /><br />
              The useRef Hook allows you to persist values between renders. It
              can be used to store a mutable value that does not cause a
              re-render when updated. It can be used to access a DOM element
              directly.
            </aside>
          </section>
          <section class="text-slide">
            <h4 class="slide-name">hooks - rules</h4>
            <p>
              <strong>Only Call Hooks from React Functions</strong><br />
              Don't call Hooks from regular JavaScript functions.
            </p>
            <p>
              <strong>Only Call Hooks at the Top Level </strong><br />
              Don't call Hooks inside loops, conditions, or nested functions.
            </p>
            <aside class="notes">
              1. Don't call Hooks from regular JavaScript functions. Instead,
              you can: Call Hooks from React function components. Call Hooks
              from custom Hooks
              <br /><br />
              2. Don't call Hooks inside loops, conditions, or nested functions.
              Instead, always use Hooks at the top level of your React function,
              before any early returns. By following this rule, you ensure that
              Hooks are called in the same order each time a component renders.
            </aside>
          </section>
          <section class="text-slide">
            <h4 class="slide-name">hooks - custom hooks</h4>
            <p class="text-center-align">
              A custom Hook is a JavaScript function whose name starts with
              ”use” and that may call other Hooks.
            </p>
            <aside class="notes">
              Building your own Hooks lets you extract component logic into
              reusable functions. When we want to share logic between two
              JavaScript functions, we extract it to a third function. Both
              components and Hooks are functions, so this works for them too!
              <br /><br />
              Unlike a React component, a custom Hook doesn't need to have a
              specific signature. We can decide what it takes as arguments, and
              what, if anything, it should return. In other words, it's just
              like a normal function. Its name should always start with use and
              let's look to the example.
            </aside>
          </section>
        </section>

        <!-- USE-STATE EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useState example</h4>
            <div>
              <img
                src="assets/images/use_state_example.png"
                alt="use_state_example"
              />
              <ol>
                <li>
                  Create folder <strong>hooks</strong> inside your
                  <strong>src</strong> folder
                </li>
                <li>
                  Create <strong>index.js</strong> inside
                  <strong>hooks</strong> folder
                </li>
                <li>
                  Create <strong>use-state-component.js</strong> inside
                  <strong>hooks</strong> folder
                </li>
                <li>
                  Start coding <strong>UseStateComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useState example - UseStateComponent</h4>
            <p>Let's create UseStateComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState } from "react";

                export const UseStateComponent = () => {
                  const [counter, setCounter] = useState(0);

                  return (
                    <div>
                      <h2>Use state component</h2>
                      <div>{counter}</div>
                      &lt;button onClick={() => setCounter(counter + 1)}>
                        Add
                      &lt;/button>
                    </div>
                  );
                };
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useState example - UseStateComponent</h4>
            <p>We also can set state in this way...</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="10">
                import React, { useState } from "react";

                export const UseStateComponent = () => {
                  const [counter, setCounter] = useState(0);

                  return (
                    <div>
                      <h2>Use state component</h2>
                      <div>{counter}</div>
                      &lt;button onClick={() => setCounter((prevCount) => prevCount + 1)}>
                        Add
                      &lt;/button>
                    </div>
                  );
                };
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useState example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import { UseStateComponent } from "./use-state-component";

                export {
                  UseStateComponent
                };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useState example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="9-11,13,18,24,30-34">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useState example - result</h4>
            <div>
              <iframe data-src="assets/videos/use_state_example.mp4"></iframe>
            </div>
          </section>
        </section>

        <!-- USE-EFFECT EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useEffect example</h4>
            <div>
              <img
                src="assets/images/use_effect_example.png"
                alt="use_effect_example"
              />
              <ol>
                <li>
                  Create <strong>use-effect-component.js</strong> inside
                  <strong>hooks</strong> folder
                </li>
                <li>
                  Start coding <strong>UseEffectComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useEffect example - UseEffectComponent</h4>
            <p>Let's create UseEffectComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState, useEffect } from "react";

                export const UseEffectComponent = () => {
                  const [title, setTitle] = useState("Title");

                  useEffect(() => {
                    console.log("Fetch data...");
                    setTimeout(() => setTitle("New title"), 3000);

                    return () => {
                      console.log("remove listeners and etc.");
                    };
                  }, []);

                  return (
                    <div>
                      <h2>Use effect component</h2>
                      <div>{title}</div>
                    </div>
                  );
                };
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useEffect example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="2,6">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";

                export {
                  UseStateComponent,
                  UseEffectComponent
                };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useEffect example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="11,34">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useEffect example - result</h4>
            <div>
              <iframe data-src="assets/videos/use_effect_example.mp4"></iframe>
            </div>
          </section>
        </section>

        <!-- USE-CALLBACK EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useCallback example</h4>
            <div>
              <img
                src="assets/images/use_callback_example.png"
                alt="use_callback_example"
              />
              <ol>
                <li>
                  Create <strong>use-callback-component.js</strong> inside
                  <strong>hooks</strong> folder
                </li>
                <li>
                  Start coding <strong>UseCallbackComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              useCallback example - UseCallbackComponent
            </h4>
            <p>Let's create UseCallbackComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState, useCallback, memo } from "react";

                export const UseCallbackComponent = () => {
                  const [count, setCount] = useState(0);
                  const [items, setItems] = useState([]);

                  const increment = () => {
                    setCount((c) => c + 1);
                  };

                  const handleClick = useCallback(() => {
                    setItems(() => [...items, "New item"]);
                  }, [items]);

                  return (
                    &lt;>
                      <h2>Use callback component</h2>
                      &lt;MemoComponent onClick={handleClick} />
                      <br />
                      <div>
                        <span>Count: {count}</span>
                        <button onClick={increment}>+</button>
                      </div>
                    &lt;/>
                  );
                };

                const InnerComponent = ({ onClick }) => {
                  console.log("child render");
                  return <button onClick={onClick}>Button</button>;
                };

                const MemoComponent = memo(InnerComponent);
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useCallback example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="3,8">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent
                };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useCallback example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="12,36">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useEffect example - result</h4>
            <div>
              <iframe
                data-src="assets/videos/use_callback_example_1.mp4"
              ></iframe>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              useCallback example - UseCallbackComponent
            </h4>
            <p>Now let's try without useCallback and let's difference</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="11-13">
                import React, { useState, useCallback, memo } from "react";

                export const UseCallbackComponent = () => {
                  const [count, setCount] = useState(0);
                  const [items, setItems] = useState([]);

                  const increment = () => {
                    setCount((c) => c + 1);
                  };

                  const handleClick = () => {
                    setItems(() => [...items, "New item"]);
                  }

                  return (
                    &lt;>
                      <h2>Use callback component</h2>
                      &lt;MemoComponent onClick={handleClick} />
                      <br />
                      <div>
                        <span>Count: {count}</span>
                        <button onClick={increment}>+</button>
                      </div>
                    &lt;/>
                  );
                };

                const InnerComponent = ({ onClick }) => {
                  console.log("child render");
                  return <button onClick={onClick}>Button</button>;
                };

                const MemoComponent = memo(InnerComponent);
					    </code>
            </pre>
            <aside class="notes">
              Let's try without useCallback. We are using memo, so the
              InnerComponent component should not re-render since onClick is not
              changing.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useEffect example - without useCallback</h4>
            <div>
              <iframe
                data-src="assets/videos/use_callback_example_2.mp4"
              ></iframe>
            </div>
            <aside class="notes">
              Why it is rerendered? This is because of every time a component
              re-renders, its functions get recreated.
            </aside>
          </section>
        </section>

        <!-- USE-CONTEXT EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useContext example</h4>
            <div>
              <img
                src="assets/images/use_context_example.png"
                alt="use_context_example"
              />
              <ol>
                <li>
                  Create <strong>use-context-component.js</strong> inside
                  <strong>hooks</strong> folder
                </li>
                <li>
                  Start coding <strong>UseContextComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useContext example - UseContextComponent</h4>
            <p>Let's create UseContextComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useContext } from "react";

                const themes = {
                  blue: {
                    textColor: "blue"
                  },
                  red: {
                    textColor: "red"
                  }
                };

                const ThemeContext = React.createContext(themes.blue);

                export const UseContextComponent = () => {
                  return (
                    &lt;ThemeContext.Provider value={themes.red}>
                      &lt;InnerComponent />
                    &lt;/ThemeContext.Provider>
                  );
                };

                const InnerComponent = () => {
                  const theme = useContext(ThemeContext);

                  return (
                    <div>
                      <h2>Use context component</h2>
                      &lt;p style={{ color: theme.textColor }}>Themed text&lt;/p>
                    </div>
                  );
                };
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useContext example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4,10">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";
                import { UseContextComponent } from "./use-context-component";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent
                };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useContext example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="13,38">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="picture-slide">
            <h4 class="slide-name">useContext example - result</h4>
            <img
              src="assets/images/use_context_example_result.png"
              class="with-border"
              alt="use_context_example_result"
            />
          </section>
        </section>

        <!-- USE-MEMO EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useMemo example</h4>
            <div>
              <img
                src="assets/images/use_memo_example.png"
                alt="use_memo_example"
              />
              <ol>
                <li>
                  Create <strong>use-memo-component.js</strong> inside
                  <strong>hooks</strong> folder
                </li>
                <li>
                  Start coding <strong>UseMemoComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useMemo example - UseMemoComponent</h4>
            <p>Let's create UseMemoComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState, useMemo } from "react";

                export const UseMemoComponent = () => {
                  return (
                    &lt;>
                      <h2>Use memo component</h2>
                      &lt;InnerComponent value={30} />
                    &lt;/>
                  );
                };

                const InnerComponent = ({ value }) => {
                  const [count, setCount] = useState(0);

                  const calculated = useMemo(() => {
                    console.log("some calculations here");
                    return value * 2;
                  }, [value]);

                  return (
                    &lt;>
                      <p>Count: {count}</p>
                      <p>Calculated: {calculated}</p>
                      &lt;button onClick={() => setCount((c) => c + 1)}>Button&lt;/button>
                    &lt;/>
                  );
                };
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useMemo example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="5,12">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";
                import { UseContextComponent } from "./use-context-component";
                import { UseMemoComponent } from "./use-memo-component";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent
                };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useMemo example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="14,40">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useMemo example - result</h4>
            <div>
              <iframe data-src="assets/videos/use_memo_example_1.mp4"></iframe>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useMemo example - without useMemo</h4>
            <p>Now let's try without useMemo and let's difference</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="15-18">
                import React, { useState, useMemo } from "react";

                export const UseMemoComponent = () => {
                  return (
                    &lt;>
                      <h2>Use memo component</h2>
                      &lt;InnerComponent value={30} />
                    &lt;/>
                  );
                };

                const InnerComponent = ({ value }) => {
                  const [count, setCount] = useState(0);

                  const calculated = (() => {
                    console.log("some calculations here");
                    return value * 2;
                  })();

                  return (
                    &lt;>
                      <p>Count: {count}</p>
                      <p>Calculated: {calculated}</p>
                      &lt;button onClick={() => setCount((c) => c + 1)}>Button&lt;/button>
                    &lt;/>
                  );
                };
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useMemo example - result</h4>
            <div>
              <iframe data-src="assets/videos/use_memo_example_2.mp4"></iframe>
            </div>
          </section>
        </section>

        <!-- USE-REF EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useRef example</h4>
            <div>
              <img
                src="assets/images/use_ref_example.png"
                alt="use_ref_example"
              />
              <ol>
                <li>
                  Create <strong>use-ref-component.js</strong> inside
                  <strong>hooks</strong> folder
                </li>
                <li>Start coding <strong>UseRefComponent</strong> component</li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useRef example - UseRefComponent</h4>
            <p>Let's create UseRefComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState, useEffect, useRef } from "react";

                export const UseRefComponent = () => {
                  const [inputValue, setInputValue] = useState("");
                  const count = useRef(0);

                  useEffect(() => {
                    count.current = count.current + 1;
                  });

                  return (
                    &lt;>
                      <h2>Use Ref component</h2>
                      &lt;input
                        type="text"
                        value={inputValue}
                        onChange={(e) => setInputValue(e.target.value)}
                      />
                      <h1>Render Count: {count.current}</h1>
                    &lt;/>
                  );
                };
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useRef example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="6,14">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";
                import { UseContextComponent } from "./use-context-component";
                import { UseMemoComponent } from "./use-memo-component";
                import { UseRefComponent } from "./use-ref-component";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent
                };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useRef example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="15,42">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useRef example - result</h4>
            <div>
              <iframe data-src="assets/videos/use_ref_example.mp4"></iframe>
            </div>
          </section>
        </section>

        <!-- CUSTOM HOOK EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">custom hook example</h4>
            <div>
              <img
                src="assets/images/custom_hook_example.png"
                alt="custom_hook_example"
              />
              <ol>
                <li>
                  Create <strong>use-custom-hook-component.js</strong> inside
                  <strong>hooks</strong> folder
                </li>
                <li>
                  Start coding <strong>UseCustomHookComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">custom hook - UseCustomHookComponent</h4>
            <p>Let's create UseRefComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState, useEffect } from "react";

                const useData = () => {
                  const [data, setData] = useState();
                  const [loading, setLoading] = useState(true);

                  useEffect(() => {
                    console.log("Fetch custom hook data ...");
                    setTimeout(() => {
                      setData("data");
                      setLoading(false);
                    }, 3000);
                  }, []);

                  return { data, loading };
                };

                export const UseCustomHookComponent = () => {
                  const { data, loading } = useData();

                  return (
                    <div>
                      <h2>Use custom hook component</h2>
                      {loading && <p>Loading</p>}
                      {data && <div>{data}</div>}
                    </div>
                  );
                };
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">custom hook - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="7,16">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";
                import { UseContextComponent } from "./use-context-component";
                import { UseMemoComponent } from "./use-memo-component";
                import { UseRefComponent } from "./use-ref-component";
                import { UseCustomHookComponent } from "./use-custom-hook-component.js";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">custom hook example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="16,44">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">custom hook example - result</h4>
            <div>
              <iframe data-src="assets/videos/custom_hook_example.mp4"></iframe>
            </div>
          </section>
        </section>

        <!-- ADDITIONAL MATERIALS -->
        <section class="video-text-slide">
          <h4 class="slide-name">Additional materials</h4>
          <div>
            <div>
              <a
                href="https://www.youtube.com/watch?v=dpw9EHDh2bM
              "
                target="_blank"
                >React Today and Tomorrow
              </a>
              <iframe
                src="https://www.youtube.com/embed/dpw9EHDh2bM"
                title="React Today and Tomorrow"
                allowfullscreen
              >
              </iframe>
            </div>
            <div>
              <p>
                <strong>Sophie Alpert</strong> - manage the react core team at
                Facebook;
                <br />
                <strong>Dan Abramov</strong> - works at react team;
                <br />
                <strong>Ryan Florence</strong> - was involved to the developing
                of several react libraries.
              </p>
              <p>
                - Why react is more popular then other stuff and what problems
                he has;
                <br />
                - How hooks can help us to solve those problems;
                <br />
                - Why we should rewrite our apps with hooks.
              </p>
            </div>
          </div>
          <aside class="notes">
            The first three talks from React Conf 2018 by Sophie Alpert, Dan
            Abramov, and Ryan Florence.
            <br /><br />
            Third speaker with show how hooks feel in a little bit more
            real-world use case.
          </aside>
        </section>

        <!-- HOC-s -->
        <section class="text-and-conding-slide">
          <h4 class="slide-name">HOC-s</h4>
          <div class="center-align">
            <p>
              HOC is a function that takes a component and returns a new
              component
            </p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
							const EnhancedComponent = withHoc(WrappedComponent); 
						</code>
					</pre>
          </div>
          <aside class="notes">
            A higher-order component (HOC) is an advanced technique in React for
            reusing component logic. Components are the primary unit of code
            reuse in React.
            <br /><br />
            HOC doesn't modify the input component, nor does it use inheritance
            to copy its behavior. Rather, a HOC<strong>composes</strong> the
            original component by <strong>wrapping</strong> it in a container
            component. A HOC is a pure function with zero side-effects.
            <br /><br />
            The wrapped component receives all the props of the container, along
            with a new prop, <strong>data</strong>, which it uses to render its
            output.
          </aside>
        </section>

        <!-- HOC EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">HOC example</h4>
            <div>
              <img src="assets/images/hoc_example.png" alt="hoc_example" />
              <ol>
                <li>
                  Create folder <strong>hoc</strong> inside your
                  <strong>src</strong> folder
                </li>
                <li>
                  Create <strong>index.js</strong> inside
                  <strong>hoc</strong> folder
                </li>
                <li>
                  Create <strong>hoc-component.js</strong> inside
                  <strong>hoc</strong> folder
                </li>
                <li>Start coding <strong>HocComponent</strong> component</li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">HOC example - HocComponent</h4>
            <p>Let's create HocComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState, useEffect } from "react";

                const withInternetCheck = (Component) => (props) => {
                  const [isInternetReachable, setIsInternetReachable] = useState(false);

                  useEffect(() => {
                    console.log("Check internet...");
                    setTimeout(() => setIsInternetReachable(true), 7000);
                  }, []);

                  return (
                    &lt;>
                      {!isInternetReachable && <p>No internet</p>}
                      &lt;Component injectedProp={isInternetReachable} {...props} />
                    &lt;/>
                  );
                };

                const _HocComponent = (props) => {
                  const { injectedProp } = props;

                  return (
                    <div>
                      <h2>With HOC component</h2>
                      <p>Is internet reachable: {`${injectedProp}`}</p>
                    </div>
                  );
                };

                export const HocComponent = withInternetCheck(_HocComponent);
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">HOC example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import { HocComponent } from "./hoc-component";

                export { HocComponent };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">HOC example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="18,48-51">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";
                import { HocComponent } from "./hoc";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>HOCs</h1>
                        &lt;HocComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">HOC example - result</h4>
            <div>
              <iframe data-src="assets/videos/hoc_example.mp4"></iframe>
            </div>
          </section>
        </section>

        <!-- CONTROLLED COMPONENTS -->
        <section class="picture-slide">
          <h4 class="slide-name">CONTROLLED COMPONENTS</h4>
          <img
            src="assets/images/controlled_components.png"
            alt="controlled_components"
          />
          <aside class="notes">
            Controlled vs uncontrolled components
            <br /><br />
            Let's start with controlled components.<br />
            As the name says, in the controlled component the form input
            element's values and mutations are totally driven by event handlers
            and the value of the input element is always inferred from the
            state. Here's a flow diagram of a controlled component
            <br /><br />
            Let's understand the two most important aspects of controlled
            components<br />
            * The component has the <strong>value</strong> attribute set as the
            components state. This is very important so that
            <strong>the input</strong> component's value will always be in sync
            with the components state value.<br />
            * Secondly, we are handling the change event emitted by the element
            whenever a user tries to update the element's value. Inside the
            handler function, we are <strong>mutating</strong> the state with
            the updated input value.<br />
          </aside>
        </section>

        <!-- CONTROLLED EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">Controlled component example</h4>
            <div>
              <img
                src="assets/images/controlled_component_example.png"
                alt="controlled_component_example"
              />
              <ol>
                <li>
                  Create folder <strong>controlled-uncontrolled</strong> inside
                  your <strong>src</strong> folder
                </li>
                <li>
                  Create <strong>index.js</strong> inside
                  <strong>controlled-uncontrolled</strong> folder
                </li>
                <li>
                  Create <strong>controlled-component.js</strong> inside
                  <strong>controlled-uncontrolled</strong> folder
                </li>
                <li>
                  Start coding <strong>ControlledComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              Controlled component example - ControlledComponent
            </h4>
            <p>Let's create ControlledComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState } from "react";

                const ControlledComponent = () => {
                  const [name, setName] = useState("");
                  const [email, setEmail] = useState("");

                  const onSubmit = () => {
                    console.log("Name value: " + name);
                    console.log("Email value: " + email);
                  };

                  return (
                    <div>
                      <h3>Controlled Component</h3>
                      &lt;form onSubmit={onSubmit}>
                        &lt;input
                          type="text"
                          name="name"
                          value={name}
                          onChange={(e) => setName(e.target.value)}
                          required
                        />
                        &lt;input
                          type="email"
                          name="email"
                          value={email}
                          onChange={(e) => setEmail(e.target.value)}
                          required
                        />
                        <input type="submit" value="Submit" />
                      &lt;/form>
                    </div>
                  );
                };

                export default ControlledComponent;
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Controlled component example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import ControlledComponent from "./controlled-component";

                export { ControlledComponent };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">Controlled component example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="19,53-57">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";
                import { HocComponent } from "./hoc";
                import { ControlledComponent } from "./controlled-uncontrolled";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>HOCs</h1>
                        &lt;HocComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Controlled and uncontrolled components</h1>
                        &lt;ControlledComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="picture-slide">
            <h4 class="slide-name">Controlled component example - result</h4>
            <img
              src="assets/images/controlled_component_example_1.png"
              alt="controlled_component_example_1"
            />
          </section>
        </section>

        <!-- UNCONTROLLED COMPONENTS -->
        <section class="picture-slide">
          <h4 class="slide-name">UNCONTROLLED COMPONENTS</h4>
          <img
            src="assets/images/uncontrolled_components.png"
            alt="uncontrolled_components"
          />
          <aside class="notes">
            How uncontrolled components work?
            <br /><br />
            They don't use any states on input elements or any event handler.
            This type of component doesn't care about an input element's
            real-time value changes.
            <br /><br />
            In the uncontrolled components, we use Refs to access the values of
            input elements.
            <br /><br />
            Why Controlled vs uncontrolled components are required?<br />
            React provides both a model-view approach with controlled components
            and an only view approach using uncontrolled components. <br />
            While other frameworks like Angular or VueJs provide only Model-View
            two-way binding approach to the same use case, React provides two
            distinctively flexible solutions. <br />
            It depends on the use cases about how and where one would use any of
            those.
          </aside>
        </section>

        <!-- UNCONTROLLED EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">Uncontrolled component example</h4>
            <div>
              <img
                src="assets/images/uncontrolled_component_example.png"
                alt="uncontrolled_component_example"
              />
              <ol>
                <li>
                  Create <strong>uncontrolled-component.js</strong> inside
                  <strong>controlled-uncontrolled</strong> folder
                </li>
                <li>
                  Start coding <strong>UncontrolledComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              Uncontrolled component example - UncontrolledComponent
            </h4>
            <p>Let's create UncontrolledComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useRef } from "react";

                const UncontrolledComponent = () => {
                  const nameRef = useRef();
                  const emailRef = useRef();

                  const onSubmit = () => {
                    console.log("Name value: " + nameRef.current.value);
                    console.log("Email value: " + emailRef.current.value);
                  };

                  return (
                    <div>
                      <h3>Uncontrolled Component</h3>
                      &lt;form onSubmit={onSubmit}>
                        &lt;input type="text" name="name" ref={nameRef} required />
                        &lt;input type="email" name="email" ref={emailRef} required />
                        &lt;input type="submit" value="Submit" />
                      &lt;/form>
                    </div>
                  );
                };

                export default UncontrolledComponent;
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              Uncontrolled component example - INDEX.JS
            </h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="2,4">
                import ControlledComponent from "./controlled-component";
                import UncontrolledComponent from "./uncontrolled-component";

                export { ControlledComponent, UncontrolledComponent };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">Uncontrolled component example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="19-22,60">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";
                import { HocComponent } from "./hoc";
                import {
                  ControlledComponent,
                  UncontrolledComponent
                } from "./controlled-uncontrolled";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>HOCs</h1>
                        &lt;HocComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Controlled and uncontrolled components</h1>
                        &lt;ControlledComponent />
                        &lt;UncontrolledComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="picture-slide">
            <h4 class="slide-name">Uncontrolled component example - result</h4>
            <img
              src="assets/images/uncontrolled_component_example_1.png"
              alt="uncontrolled_component_example_1"
            />
          </section>
        </section>

        <!-- RECONCILIATION -->
        <section>
          <section class="text-slide">
            <h4 class="slide-name">RECONCILIATION</h4>
            <p>
              DOM operations are heavy -> Virtual DOM
              <br /><br /><br />
              To <strong>diff update tree with previous</strong> tree to
              determine which parts need to be changed. <br /><br /><br />
              Virtual DOM -> rendering environment -> update (changing state) ->
              reconciliation (new tree diffed with the old one) -> update
              rendering environment
            </p>
            <aside class="notes">
              When you use React, at a single point in time you can think of the
              <strong>render()</strong> function as creating a tree of React
              elements. <br />
              On the next state or props update, that
              <strong>render()</strong> function will return a different tree of
              React elements. <br />
              React then needs to figure out how to efficiently update the UI to
              match the most recent tree.
              <br /><br />
              Let's start with Virtual DOM, this is a representation in the form
              of an object of the state of our application and through the
              libraries it matches to the browser-DOM or react-native.<br />
              DOM operations are very heavy and modifying objects is very
              easy.<br />
              Rendering takes place in two stages Reconciling and updating.
              <br /><br />
              Reconciliation is when two trees are taken, compared and it
              determines which parts of this tree have changed and should be
              redrawn.
              <br /><br />
              There is one typical picture of how our application rerenders.<br />
              There is a virtual DOM that is re-rendered to the environment,
              this is a react-DOM or a react-native, changes occur and the
              virtual-DOM changes, a re-enforcement occurs, a new tree is
              compared with the old one and an IU upgrade occurs.
            </aside>
          </section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">TWO ASSUMPTIONS FOR RECONCILIATION</h4>
            <div>
              <img
                src="assets/images/reconcilation_assumptions.png"
                alt="reconcilation_assumptions"
              />
              <ol>
                <li>
                  Two elements of different types will produce
                  <strong>different trees.</strong>
                </li>
                <li>
                  The developer can hint at which child elements may
                  <strong>be stable</strong> across different renders with a key
                  prop.
                </li>
              </ol>
            </div>
            <aside class="notes">
              For the algorithm to work quickly, there are two assumptions that
              are most often equal.
              <br /><br />
              1.<br />
              When comparing two trees, React first compares the two root
              elements. <br />
              Whenever the root elements have different types, React will tear
              down the old tree and build the new tree from scratch.<br />
              When tearing down a tree, old DOM nodes are destroyed. Component
              instances receive componentWillUnmount().
              <br /><br />
              When comparing two React DOM elements of the same type, React
              looks at the attributes of both, keeps the same underlying DOM
              node, and only updates the changed attributes.
              <br /><br />
              2. Second assumption is about using KEYS.
              <br /><br />
              Recursing On Children<br />
              By default, when recursing on the children of a DOM node, React
              just iterates over both lists of children at the same time and
              generates a mutation whenever there's a difference.<br />
              If you implement it naively, inserting an element at the beginning
              has worse performance.<br />
              In order to solve this issue, React supports a
              <strong>key</strong> attribute. <br />
              When children have keys, React uses the key to match children in
              the original tree with children in the subsequent tree.
            </aside>
          </section>
        </section>

        <!-- RECONCILIATION EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">Reconciliation example</h4>
            <div>
              <img
                src="assets/images/reconciliation_example.png"
                alt="reconciliation_example"
              />
              <ol>
                <li>
                  Create folder <strong>reconciliation</strong> inside your
                  <strong>src</strong> folder
                </li>
                <li>
                  Create <strong>index.js</strong> inside
                  <strong>reconciliation</strong> folder
                </li>
                <li>
                  Create <strong>reconciliation-component.js</strong> inside
                  <strong>reconciliation</strong> folder
                </li>
                <li>
                  Start coding
                  <strong>ReconciliationComponent</strong> component
                </li>
              </ol>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              Reconciliation example - ReconciliationComponent
            </h4>
            <p>Let's create ReconciliationComponent</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState, useEffect, memo } from "react";

                const ReconciliationComponent = () => {
                  const [items, setItems] = useState([
                    { name: "item 1", key: "item_1" },
                    { name: "item 30", key: "item_30" },
                    { name: "item 70", key: "item_70" },
                    { name: "item 130", key: "item_130" }
                  ]);

                  const handleAddToTop = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  const handleAddToBottom = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  return (
                    &lt;>
                      <ul>
                        {items.map((i) => (
                          &lt;li key={i.key}>
                            &lt;InnerComponent name={i.name} />
                          &lt;/li>
                        ))}
                      </ul>
                      &lt;button onClick={handleAddToTop}>Add to top&lt;/button>
                      &lt;button onClick={handleAddToBottom}>Add to bottom&lt;/button>
                    &lt;/>
                  );
                };

                const _InnerComponent = ({ name }) => {
                  useEffect(
                    () => () => {
                      console.log(`unmount inner component: ${name}`);
                    },
                    [name]
                  );

                  return <p>Inner component {name}</p>;
                };

                const InnerComponent = memo(_InnerComponent);

                export default ReconciliationComponent;
					    </code>
            </pre>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Reconciliation example - INDEX.JS</h4>
            <p>Let's the following code to the index.js file</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,3">
                import ReconciliationComponent from "./reconciliation-component";

                export { ReconciliationComponent };
					    </code>
            </pre>
            <aside class="notes"></aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">Reconciliation example - APP.JS</h4>
            <p>
              And the last thing we need to do is add our new component to
              App.js
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="23,64-67">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";
                import { HocComponent } from "./hoc";
                import {
                  ControlledComponent,
                  UncontrolledComponent
                } from "./controlled-uncontrolled";
                import { ReconciliationComponent } from "./reconciliation";                

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>HOCs</h1>
                        &lt;HocComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Controlled and uncontrolled components</h1>
                        &lt;ControlledComponent />
                        &lt;UncontrolledComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Reconciliation</h1>
                        &lt;ReconciliationComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">Reconciliation example - result</h4>
            <div>
              <iframe
                data-src="assets/videos/reconciliation_example.mp4"
              ></iframe>
            </div>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">
              Reconciliation example - ReconciliationComponent
            </h4>
            <p>Let's try without keys now</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="27-29">
                import React, { useState, useEffect, memo } from "react";

                const ReconciliationComponent = () => {
                  const [items, setItems] = useState([
                    { name: "item 1", key: "item_1" },
                    { name: "item 30", key: "item_30" },
                    { name: "item 70", key: "item_70" },
                    { name: "item 130", key: "item_130" }
                  ]);

                  const handleAddToTop = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  const handleAddToBottom = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  return (
                    &lt;>
                      <ul>
                        {items.map((i) => (
                          &lt;li>
                            &lt;InnerComponent name={i.name} />
                          &lt;/li>
                        ))}
                      </ul>
                      &lt;button onClick={handleAddToTop}>Add to top&lt;/button>
                      &lt;button onClick={handleAddToBottom}>Add to bottom&lt;/button>
                    &lt;/>
                  );
                };

                const _InnerComponent = ({ name }) => {
                  useEffect(
                    () => () => {
                      console.log(`unmount inner component: ${name}`);
                    },
                    [name]
                  );

                  return <p>Inner component {name}</p>;
                };

                const InnerComponent = memo(_InnerComponent);

                export default ReconciliationComponent;
					    </code>
            </pre>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">Reconciliation example - result</h4>
            <div>
              <iframe
                data-src="assets/videos/reconciliation_example_1.mp4"
              ></iframe>
            </div>
          </section>
        </section>

        <!-- FIBER -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">REACT FIBER</h4>
            <div>
              <img src="assets/images/fiber.png" alt="fiber" />
              <ol>
                <li>
                  A fiber represents a virtual stack frame with scheduling and
                  prioritizing
                </li>
                <li>
                  <strong>window.requestIdleCallback(callback)</strong
                  ><br />schedules a low priority function to be called during
                  an idle period
                </li>
                <li>
                  <strong>window.requestAnimationFrame(callback); </strong
                  ><br />schedules a high priority function to be called on the
                  next animation frame
                </li>
              </ol>
            </div>
            <aside class="notes">
              React Fiber is a complete rewrite of React's reconciler algorithm
              to fix some of the longstanding problems in React. The main
              feature is that it implements incremental rendering.
              <br /><br />
              Because Fiber is asynchronous, React can:<br />
              - Pause, resume, and restart rendering work on components as new
              updates come in<br />
              - Reuse previously completed work and even abort it if not
              needed<br />
              - Split work into chunks and prioritize tasks based on importance
              <br /><br />
              By the end of the reconciliation, React knows the result of the
              DOM tree, and a renderer like react-dom or react-native applies
              the minimal set of changes necessary to update the DOM nodes.This
              means that when you call ReactDOM.render() or setState(), React
              performs reconciliation.
              <br /><br />
              What is the React stack reconciler?<br />
              Oh, by the way, why is this called the “stack” reconciler? This
              name is derived from the “stack” data structure, which is a
              last-in, first-out mechanism.<br />
              And, what does stack have anything to do with what we just saw?
              Well, as it turns out, since we are effectively performing
              recursion, it has everything to do with a stack.
              <br /><br />
              The picture shows the main idea, which allows you to redraw UI at
              least 16 ms, 16 ms is 60 frames per second, which allows you to
              adjust the feeling that UI does not slow down.
              <br /><br />
              All tasks are divided into small iterations and executed. Views
              have two callbacks requestIdleCallback and
              requestAnimationFrame.<br />
              requestIdleCallback is called when the browser puts down,
              requestIdleCallback is called for higher priority tasks.
            </aside>
          </section>
          <section class="bullets-slide">
            <h4 class="slide-name">REACT FIBER</h4>
            <ul>
              <li class="fragment">pause work and come back to it later</li>
              <li class="fragment">
                assign priority to different types of work
              </li>
              <li class="fragment">reuse previously completed work</li>
              <li class="fragment">abort work if it's no longer needed</li>
            </ul>
            <aside class="notes">
              The slide shows the features of how a fiber can manage tasks
            </aside>
          </section>
        </section>

        <!-- ADDITIONAL MATERIALS -->
        <section class="video-text-slide">
          <h4 class="slide-name">ADDITIONAL MATERIALS</h4>
          <div>
            <div>
              <a
                href="https://www.youtube.com/watch?v=ZCuYPiUIONs"
                target="_blank"
                >A Cartoon Intro to Fiber
              </a>
              <iframe
                src="https://www.youtube.com/embed/ZCuYPiUIONs"
                title="A Cartoon Intro to Fiber
                "
                allowfullscreen
              >
              </iframe>
            </div>
            <div>
              <p>
                <strong>Lin Clark</strong> - work in the emerging technologies
                group at Mozilla.
              </p>
              <p>- Basics about Fiber</p>
            </div>
          </div>
        </section>

        <!-- QA -->
        <section class="qa-slide">
          <h4>QA</h4>
        </section>
      </div>
    </div>
    <script src="../reveal-js/dist/reveal.js"></script>
    <script src="../reveal-js/plugin/zoom/zoom.js"></script>
    <script src="../reveal-js/plugin/notes/notes.js"></script>
    <script src="../reveal-js/plugin/search/search.js"></script>
    <script src="../reveal-js/plugin/markdown/markdown.js"></script>
    <script src="../reveal-js/plugin/highlight/highlight.js"></script>
    <script>
      var url = new URL(window.location.href);
      var showNotes = url.searchParams.has("showNotes");

      Reveal.initialize({
        disableLayout: true,
        controls: true,
        progress: true,
        center: false,
        hash: true,
        autoPlayMedia: true,
        showNotes,
        plugins: [
          RevealZoom,
          RevealNotes,
          RevealSearch,
          RevealMarkdown,
          RevealHighlight,
        ],
      });
    </script>
  </body>
</html>
