<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>rolling-scopes-school/react-native-course - React module</title>
    <meta
      name="description"
      content="rolling-scopes-school/react-native-course - name module"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/dist/reset.css"
    />
    <link
      rel="stylesheet"
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/dist/reveal.css"
    />
    <link
      rel="stylesheet"
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/dist/theme/white.css"
      id="theme"
    />
    <!-- Theme used for syntax highlighting of code -->
    <link
      rel="stylesheet"
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/highlight/monokai.css"
    />
    <link
      rel="stylesheet"
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/common.css"
    />
    <style class="jsStyle"></style>
  </head>
  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <!-- 1-ST SLIDE -->
        <section class="presentation-name-slide">
          <h4>React</h4>

          <aside class="notes">
            <strong>ATTENTION SUPER IMPORTANT LECTION</strong>
            <br /><br />
            React is one of the most popular libraries for building user
            interfaces, and companies like Twitter, Netflix, Airbnb, and PayPal
            use it <strong>to power</strong> their frontend experiences.
            <br /><br />
            React is really awesome, and having a good command of the
            fundamentals will help you build projects of all sizes.
            <br /><br />
            Today we're <strong>going to get hands-on experience</strong> with
            React's core concepts.
          </aside>
        </section>

        <!-- AGENDA -->
        <section class="agenda-slide">
          <h4 class="slide-name">agenda</h4>
          <ul>
            <li class="fragment">
              Foundation
              <ul>
                <li>React framework</li>
                <li>JSX</li>
                <li>Components and props</li>
              </ul>
            </li>
            <li class="fragment">Component lifecycle</li>
            <li class="fragment">Hooks and HOCs</li>
            <li class="fragment">Controlled/uncontrolled components</li>
            <li class="fragment">Reconciliation</li>
            <li class="fragment">Fiber</li>
          </ul>

          <aside class="notes">
            On this slide you can see today's agenda.
            <br /><br />
            We will start with..
            <br /><br />
            Next…
            <br /><br />
            And the last one ..
          </aside>
        </section>

        <!-- FRAMEWORK -->
        <section class="picture-slide">
          <h4 class="slide-name">framework</h4>
          <img src="assets/images/Framework_slide.png" alt="Framework_slide" />

          <aside class="notes">
            Front-end development has continued to improve over the years. From
            simple static pages to now complex single-page applications, our
            tools are getting more and more powerful. Now, the
            <strong>three front-end frameworks</strong> rule the front-end
            development. <br /><br />
            When developing web pages IN THE PAST,
            <strong>
              we mainly operated the DOM through the DOM API provided by the
              browser</strong
            >. However, the DOM API is huge, and there are compatibility
            problems in different browsers. In order to simplify dom operations
            and be compatible with different browsers,
            <strong>jQuery</strong> became popular. At that time, jQuery could
            be said to be a must-learn technology for front-end developers.
            <br /><br />
            Then when developing web pages, we found that what a web page needs
            to do is to get the data from the server first, and then update the
            DOM according to the data. And this process is fixed. In order to
            simplify DOM manipulation,
            <strong>people invented the MVVM framework</strong> to automatically
            map data changes to DOM updates without the need to manually
            manipulate the DOM. This is what the front-end frameworks
            <strong>Angular, React, Vue</strong> do.
          </aside>
        </section>

        <!-- WHAT IS IT REACT? -->
        <section class="bullets-and-picture-slide">
          <h4 class="slide-name">what is it react?</h4>
          <div>
            <img src="assets/images/react.png" alt="react" />
            <ul>
              <li>Library</li>
              <li>Facebook</li>
              <li>Open-sourced</li>
              <li>React Native</li>
              <li>Thousands of stars on GitHub</li>
              <li>Amazing products</li>
            </ul>
          </div>

          <aside class="notes">
            1 - React is a JavaScript <strong>library</strong> that you can use
            to create user interfaces. <br /><br />
            2 - It was created at <strong>Facebook and open-sourced</strong> in
            March of 2013. <br /><br />
            3 - It's totally free<br /><br />
            4 - Since then, React has
            <strong>expanded beyond the web with React Native</strong>, a tool
            that allows you to create native mobile applications using React.
            <br /><br />
            5 - React is an increasingly popular library with
            <strong>tens of thousands of stars</strong> on GitHub and used in
            production by huge companies. <br /><br />
            6 - But the point of using React is not just because it's popular,
            but because its component architecture makes
            <strong>it faster and easier</strong> to build amazing products.
          </aside>
        </section>

        <!-- CODE SANDBOX -->
        <section>
          <section class="picture-with-description-slide">
            <h4 class="slide-name">code sandbox</h4>
            <img src="assets/images/code_sandbox_1.png" alt="code_sandbox_1" />
            <p>
              Open
              <a href="https://codesandbox.io/" target="_blank"
                >https://codesandbox.io/</a
              >, click "Create" button and choose React template
            </p>
            <aside class="notes">
              <strong>The quickest way</strong> to get started with a React
              project is to use CodeSandbox at codesandbox.io. <br /><br />
              Here if you <strong>click on the Create button</strong> then on
              the next page, there are a ton of different templates that you can
              use to get started with many different web development projects.
              <br /><br />
              The first of them, probably the most popular, used with
              CodeSandbox is <strong>React</strong>. So simply
              <strong>clicking on this</strong> will allow you to interact with
              some code directly in the browser, and we can see them render
              right away in the preview window.
            </aside>
          </section>

          <section class="picture-with-description-slide">
            <h4 class="slide-name">code sandbox</h4>
            <img src="assets/images/code_sandbox_2.png" alt="code_sandbox_2" />
            <p>Your project is created</p>
            <aside class="notes">
              As you can see your project has been created.<br /><br />
              On the left you have a tree of <strong>folders and files</strong>,
              the main file here is an <strong>App.js</strong> that displays a
              couple of lines on the screen. <br /><br />
              Also on the left you see a <strong>Dependencies</strong> block,
              where React is already present. <br /><br />
              In the center of the screen is the <strong>code editor</strong>.
              <br /><br />
              Well, and the last, on the right side, we have a
              <strong>window that renders</strong> our React application.
            </aside>
          </section>

          <section class="text-and-conding-slide">
            <h4 class="slide-name">code sandbox</h4>
            <p class="fragment" data-fragment-index="1">
              Let's change index.js file to avoid issue with 2 renders. Please
              paste code bellow to the index.js file.
            </p>
            <pre class="fragment" data-fragment-index="2">
                <code data-trim data-line-numbers>
                  import ReactDOM from "react-dom";

                  import App from "./App";

                  const rootElement = document.getElementById("root");
                  ReactDOM.render(&lt;App />, rootElement);
                </code>
              </pre>
            <aside class="notes">
              For further work, we need to slightly <strong>change</strong> the
              index.js file to solve a small problem with
              <strong>double renderings</strong>. <br /><br />
              Let's do this, <strong>copy the code</strong> that is provided on
              the slide and <strong>paste</strong> the file into the
              <strong>index.js</strong> file.
            </aside>
          </section>

          <section class="picture-with-description-slide">
            <h4 class="slide-name">code sandbox</h4>
            <img src="assets/images/code_sandbox_3.gif" alt="code_sandbox_3" />
            <p>You are ready to GO</p>
            <aside class="notes">
              Well that's it, we are fully <strong>ready to use</strong> our
              first React app and demonstrate the
              <strong>main features</strong> of REACT. <br /><br />
              So if you would rather use CodeSandbox instead of setting up your
              own project locally, that's absolutely fine.
              <br /><br />
              <strong>But</strong>, this SANDBOX is only recommended
              <strong>for using during education</strong>, for real project
              please use IDE (like VSCode). <br /><br />
              Since the
              <strong>main task of the course is to learn react-native</strong>,
              in our case, the SANDBOX <strong>will be enough for us</strong>.
            </aside>
          </section>
        </section>

        <!-- JSX -->
        <section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">JSX</h4>
            <div>
              <p>Embedding Expressions</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
const element = <h1>Hello, {name}</h1>;
                </code>
              </pre>
            </div>

            <div>
              <p>Specifying Attributes with JSX</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  const element = &lt;img src={source} />
                </code>
              </pre>
            </div>
            <aside class="notes">
              So let's start with JSX
              <br /><br />
              Speaking very roughly, JSX is a format for writing layout in
              React.
              <br /><br />
              <strong> JSX it is a syntax extension to JavaScript.</strong
              ><br />
              JSX may remind you of a template language, but it comes with the
              full power of JavaScript.
              <br /><br />
              <strong> Embedding Expressions in JSX</strong><br />
              You can put any valid JavaScript expression inside the curly
              braces in JSX
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">JSX</h4>
            <div>
              <p>JSX Prevents Injection Attacks</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
const element = <h1>{response.potentiallyMaliciousInput}</h1>
                </code>
              </pre>
            </div>
            <div>
              <p>JSX Represents Objects</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
const element = <h1 className="greeting">Hello, world!</h1>;
// ===
const element = React.createElement(
  "h1",
  { className: "greeting" },
  "Hello, world!"
);
                </code>
              </pre>
            </div>
            <aside class="notes">
              <strong> JSX Prevents Injection Attacks</strong><br />
              By default, React DOM escapes any values embedded in JSX before
              rendering them. Thus it ensures that you can never inject anything
              that's not explicitly written in your application. Everything is
              converted to a string before being rendered. This helps prevent
              XSS (cross-site-scripting) attacks.
              <br /><br />
              <strong>JSX Represents Objects</strong><br />
              Babel compiles JSX down to React.createElement() calls. So, two
              rows in example are identical
            </aside>
          </section>
        </section>

        <!-- COMPONENTS AND PROPS -->
        <section class="coding-and-picture-slide">
          <h4 class="slide-name">components and props</h4>
          <div>
            <img
              src="assets/images/components_and_props.png"
              alt="components_and_props"
            />
            <div>
              <div>
                <p>Functional component</p>
                <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}                    
                </code>
              </pre>
              </div>
              <div>
                <p>Class component</p>
                <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {props.name}</h1>;
  }
}       
                </code>
              </pre>
              </div>
            </div>
          </div>
          <aside class="notes">
            <strong>Components</strong> allow you to break down an interface
            into independent pieces that are easy to think of as a composition.
            They can be stacked together and used multiple times. <br /><br />
            We can imagine the <strong>application as a constructor</strong>,
            which we assemble from parts, and in this case, the parts are some
            kind of components. <br />Components can be buttons, labels, blocks
            that include other components, and so on. <br /><br />
            <strong>Why is all this necessary?</strong> I think you already
            guessed it yourself, in order to reuse components and not duplicate
            code.<br /><br />
            There are <strong>two ways</strong> to declare components in
            functional and class style. <br /><br />
            The <strong>first example</strong> on the screen shows an example of
            a functional component. This function is a component because it
            <strong>takes data</strong> in a single object
            (“<strong>props</strong>”) as a parameter and
            <strong>returns a React element</strong>. We will call such
            components "<strong>functional</strong>" because they are literally
            functions.

            <br /><br />
            You can also use an <strong>ES6 class</strong> to define the
            component, as shown <strong>in the second example</strong>.

            <br /><br />
            The above two components are equivalent from React's point of view.
          </aside>
        </section>

        <!-- CLASS COMPONENT EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">class component example</h4>
            <div>
              <img
                src="assets/images/class_component_example_0.png"
                alt="class_component_example_0"
              />
              <ol>
                <li><strong>components-and-props</strong> folder</li>
                <li><strong>index.js</strong> file</li>
                <li><strong>class-counter.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              So, let's start our <strong>first example</strong> of creating a
              class component. <br /><br />
              The first step is to prepare and
              <strong>create a several of folders and files</strong>.
              <br /><br />
              Firstly, we will create folder
              <strong>components-and-props</strong> inside src folder.
              <br /><br />
              Next, we will create <strong>index.js</strong> inside
              components-and-props folder <br /><br />
              And the last, we will create
              <strong>class-counter.js</strong> inside components-and-props
              folder <br /><br />
              Now we ready to start coding our first class component
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">class component example</h4>
            <p>class-counter.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
              import React from "react";

              class ClassCounter extends React.Component {
                render() {
                  // ...
                }
              }
              
              export default ClassCounter;
					    </code>
            </pre>
            <aside class="notes">
              Let's start creation ClassCounter component with empty render
              method
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">class component example</h4>
            <p>class-counter.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4-10">
              import React from "react";

              class ClassCounter extends React.Component {
                render() {
                  return (
                    <div>
                      <h3>{this.props.name}</h3>
                    </div>
                  );
                }
              }
              
              export default ClassCounter;
					    </code>
            </pre>
            <aside class="notes">
              Now let's add code to the render method that will display the
              third level title obtained from the properties of this component.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">class component example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import ClassCounter from "./class-counter";

                export { ClassCounter };
					    </code>
            </pre>
            <aside class="notes">
              The index.js file will contain fairly typical content, import the
              component and export it outside.
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">class component example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="3,8-11">
                import "./styles.css";

                import { ClassCounter } from "./components-and-props";
                
                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class components</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                      </div>
                    &lt;/div>
                  );
                }                
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js
            </aside>
          </section>
          <section class="picture-slide">
            <h4 class="slide-name">class component example</h4>
            <img
              src="assets/images/class_component_example.png"
              class="with-border"
              alt="class_component_example"
            />
            <aside class="notes">
              If we look at our React application, it will
              <string>look like this</string>. <br /><br />
              As you can see, our new class component
              <string>is displayed</string> on the page and there is
              <string>nothing scary</string> with creating and using components.
            </aside>
          </section>
        </section>

        <!-- FUNCTIONAL COMPONENT EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">functional component example</h4>
            <div>
              <img
                src="assets/images/functional_component_example_0.png"
                alt="functional_component_example_0"
              />
              <ol>
                <li><strong>functional-counter.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example similar to the previous one, just using a
              functional component.
              <br /><br />
              We will create
              <strong>functional-counter.js</strong> inside components-and-props
              folder <br /><br />
              Now we ready to start coding our first functional component
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">functional component example</h4>
            <p>functional-counter.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
              import React from "react";

              const FunctionalCounter = (props) => {
                
                // ...
              };
              
              export default FunctionalCounter;                
					    </code>
            </pre>
            <aside class="notes">
              As before, we'll start by creating an component with empty render
              method. <br />
              Functional components do not have a render method, its function is
              performed by the return value.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">functional component example</h4>
            <p>
              And now let's add code that will display the third level title
              obtained from the properties of this component.
            </p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4-8">
                import React from "react";

                const FunctionalCounter = (props) => {
                  return (
                    <div>
                      <h3>{props.name}</h3>
                    </div>
                  );
                };
                
                export default FunctionalCounter;                                
					    </code>
            </pre>
            <aside class="notes">
              Now let's add code to the <strong>return</strong> that will
              display the title obtained from the properties of this component.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">functional component example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="2,4">
                import ClassCounter from "./class-counter";
                import FunctionalCounter from "./functional-counter";

                export { ClassCounter, FunctionalCounter };
					    </code>
            </pre>
            <aside class="notes">
              Let's add our new component to the index and export it outside.
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">functional component example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="3,12">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";


                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      </div>
                    &lt;/div>
                  );
                }
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js
            </aside>
          </section>
          <section class="picture-slide">
            <h4 class="slide-name">functional component example</h4>
            <img
              src="assets/images/functional_component_example.png"
              class="with-border"
              alt="functional_component_example"
            />
            <aside class="notes">
              As you can see, declaring components is very simple and now the
              differences between the two types of components are not that big.
            </aside>
          </section>
        </section>

        <!-- ADDITIONAL MATERIALS -->
        <section class="video-text-slide">
          <h4 class="slide-name">additional materials</h4>
          <div>
            <div>
              <a
                href="https://www.youtube.com/watch?v=x7cQ3mrcKaY"
                target="_blank"
                >React: Rethinking best practices
              </a>
              <iframe
                src="https://www.youtube.com/embed/x7cQ3mrcKaY"
                title="React: Rethinking best practices"
                allowfullscreen
              >
              </iframe>
            </div>
            <div>
              <p>
                Author is a member of the React core team at Facebook and
                Instagram.
              </p>
              <p>
                - the notion of templates;
                <br />
                - re-rendering process;
                <br />
                - lightweight implementation of the DOM and events.
              </p>
            </div>
          </div>
          <aside class="notes">
            Author (Pete) is a member of the React core team at Facebook and
            also the sole engineer on Instagram.com.
            <br /><br />
            He has also designed and implemented the video encode backend
            infrastructure for Facebook and Instagram and computer vision
            infrastructure and general front-end web engineering for Facebook
            photos.
            <br /><br />
            This video will start with a brief introduction to the framework,
            and then dive into three controversial topics:
            <br /><br />
            - Throwing out the notion of templates and building views with
            JavaScript, <br />
            - "re-rendering" your entire application when your data changes,<br />
            - and a lightweight implementation of the DOM and events.<br />
          </aside>
        </section>

        <!-- COMPONENT LIFECYCLE -->
        <section class="picture-slide">
          <h4 class="slide-name">component lifecycle</h4>
          <img src="assets/images/react_lifecycle.png" alt="react_lifecycle" />
          <aside class="notes">
            Each component in React has a lifecycle which you can monitor and
            manipulate during its three main phases.
            <br /><br />
            The three phases are: <strong>Mounting</strong>,
            <strong>Updating</strong>, and <strong>Unmounting</strong>.
          </aside>
        </section>

        <!-- MOUNTING -->
        <section class="picture-slide">
          <h4 class="slide-name">mounting</h4>
          <img
            src="assets/images/react_lifecycle_method_mounting.png"
            alt="react_lifecycle_method_mounting"
          />
          <aside class="notes">
            This slide shows how the Mounting stage in the component lifecycle.
            <br /><br />
            In this diagram, we see functions that are called in a certain
            order.
            <br /><br />
            Let's take a closer look at an example.
          </aside>
        </section>

        <!-- MOUNTING EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">mounting example</h4>
            <div>
              <img
                src="assets/images/mounting_example.png"
                alt="mounting_example"
              />
              <ol>
                <li><strong>lifecycle</strong> folder</li>
                <li><strong>index.js</strong> file</li>
                <li><strong>mouning.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of mounting lifecycle.
              <br /><br />
              Firstly, we will create
              <strong>lifecycle</strong> folder inside src folder <br /><br />
              Next, we will create
              <strong>index.js</strong> inside lifecycle folder <br /><br />
              And the last, we will create
              <strong>mouning.js</strong> inside lifecycle folder <br /><br />
              Now we ready to start coding our mounting example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example</h4>
            <p>mouning.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                class MountingComponent extends React.Component {
                
                  render() {
                    // ...
                  }
                }
                
                export default MountingComponent;                
					    </code>
            </pre>
            <aside class="notes">
              First, let's create an empty class component called
              MountingComponent.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example</h4>
            <p>mouning.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4-11">
                import React from "react";

                class MountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      prevName: this.props.name,
                      isLoading: true,
                      lastName: null
                    };
                  }

                  render() {
                    // ...
                  }
                }
                
                export default MountingComponent;  
					    </code>
            </pre>
            <aside class="notes">
              Let's add a constructor to our component that will initialize the
              parent class and add a couple of fields to the state object.
              <br /><br />
              The <strong>constructor()</strong> method is called
              <strong>before anything else</strong>, when the component is
              initiated, and it is the natural place to set up the
              <strong>initial state</strong> and other initial values.
              <br /><br />
              The constructor() method is called with the props, as arguments,
              and you should always
              <strong>start by calling the super(props)</strong> before anything
              else, this will initiate the parent's constructor method and
              allows the component to inherit methods from its parent
              (React.Component).
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example</h4>
            <p>mounting.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="13-23">
                import React from "react";

                class MountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      prevName: this.props.name,
                      isLoading: true,
                      lastName: null
                    };
                  }

                  static getDerivedStateFromProps(props, state) {
                    if (props.name !== state.prevName) {
                      //Change in props
                      return {
                        prevName: props.name,
                        isLoading: true,
                        lastName: null
                      };
                    }
                    return null; // No change to state
                  }

                  render() {
                    // ...
                  }
                }
                
                export default MountingComponent;  
					    </code>
            </pre>
            <aside class="notes">
              Next thing that we'll add it is getDerivedStateFromProps.<br />
              This method is called next after the constructor.
              <br /><br />
              This method accepts new properties and the current state, and can
              handle updating the state.
              <br /><br />
              It should <strong>return an object</strong> to update the state,
              <strong>or null</strong> to update nothing. <br /><br />
              getDerivedStateFromProps is invoked right
              <strong>before calling the render method</strong>, both on the
              initial mount and on update stages.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example</h4>
            <p>mounting.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="25-35">
                import React from "react";

                class MountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      prevName: this.props.name,
                      isLoading: true,
                      lastName: null
                    };
                  }

                  static getDerivedStateFromProps(props, state) {
                    if (props.name !== state.prevName) {
                      //Change in props
                      return {
                        prevName: props.name,
                        isLoading: true,
                        lastName: null
                      };
                    }
                    return null; // No change to state
                  }

                  render() {
                    const [{ name }, { isLoading, lastName }] = [this.props, this.state];
                
                    if (isLoading) return <p>Loading</p>;
                
                    return (
                      <h3>
                        {name} {lastName}
                      </h3>
                    );
                  }
                }
                
                export default MountingComponent;  
					    </code>
            </pre>
            <aside class="notes">
              And now let's implement the render method and add some logic
              related to the loading state.
              <br /><br />
              The render() method is the most used lifecycle method. You will
              see it in all React classes. <br />
              <br />
              This is because <strong>render()</strong>is the only required
              method within a class component in React. <br />
              <br />As the name suggests it handles the rendering of your
              component to the UI. It happens during the
              <strong>mounting</strong> and <strong>updating</strong> of your
              component.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example</h4>
            <p>mounting.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="25-29">
                import React from "react";

                class MountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      prevName: this.props.name,
                      isLoading: true,
                      lastName: null
                    };
                  }

                  static getDerivedStateFromProps(props, state) {
                    if (props.name !== state.prevName) {
                      //Change in props
                      return {
                        prevName: props.name,
                        isLoading: true,
                        lastName: null
                      };
                    }
                    return null; // No change to state
                  }

                  componentDidMount() {
                    setTimeout(() => {
                      this.setState({ isLoading: false, lastName: "LastName" });
                    }, 3000);
                  }

                  render() {
                    const [{ name }, { isLoading, lastName }] = [this.props, this.state];
                
                    if (isLoading) return <p>Loading</p>;
                
                    return (
                      <h3>
                        {name} {lastName}
                      </h3>
                    );
                  }
                }
                
                export default MountingComponent;  
					    </code>
            </pre>
            <aside class="notes">
              The last thing is componentDidMount.
              <br /><br />
              Now your component has been mounted and ready, that's when the
              next React lifecycle method
              <strong>componentDidMount()</strong>comes in play. <br /><br />
              It is called as soon as the component is mounted and ready.
              <br /><br />
              This method is a good place to
              <strong>set up any subscriptions</strong>. If you do that,
              <strong>don't forget to unsubscribe</strong> in
              componentWillUnmount().
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">mounting example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import MountingComponent from "./mouning";

                export { MountingComponent };
					    </code>
            </pre>
            <aside class="notes">
              The index.js file will contain fairly typical content, import the
              component and export it outside.
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">mounting example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4,14-18">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { MountingComponent } from "./lifecycle";

                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      </div>
                      <br /> <br />
                      <div>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                      </div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">mounting example</h4>
            <div>
              <iframe data-src="assets/videos/mounting_example.mp4"></iframe>
            </div>
            <aside class="notes">
              As we can see, our component works exclusively as we wanted from
              it.
              <br />
              <br />
              We set the initial load state in the constructor to true, then in
              componentDidMount we set a timeout, which will set the loading to
              the false and change the name.
            </aside>
          </section>
        </section>

        <!-- UPDATING -->
        <section class="picture-slide">
          <h4 class="slide-name">updating</h4>
          <img
            src="assets/images/react_lifecycle_method_updating.png"
            alt="react_lifecycle_method_updating"
          />
          <aside class="notes">
            This slide shows how the Updating stage in the component lifecycle.
            <br /><br />
            In this diagram, we see functions that are called in a certain
            order.
            <br /><br />
            Let's take a closer look at an example.
          </aside>
        </section>

        <!-- UPDATING EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">updating example</h4>
            <div>
              <img
                src="assets/images/updating_example.png"
                alt="updating_example"
              />
              <ol>
                <li><strong>updating.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of updating lifecycle methods.
              <br /><br />
              We will create
              <strong>updating.js</strong> inside lifecycle folder <br /><br />
              And now we ready to start coding our updating example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example</h4>
            <p>updating.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  render() {
                    // ...
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              Let's create MountingComponent with empty render method and two
              arrays in the state to store counter values
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example</h4>
            <p>updating.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="14-34">
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  return (
                    // ...
                  );
                }

                class Counter extends React.Component {
                  // Get box DOM reference
                  buttonRef = React.createRef();

                  render() {
                    console.log(`Rendering ${this.props.name}`);
                    return (
                      <div>
                        <h2>{this.props.name}:</h2>
                        <div>
                          {this.props.value.map((e, index) => (
                            <p key={index}>{e}</p>
                          ))}
                        </div>
                        <button ref={this.buttonRef} onClick={this.props.onClick}>
                          Add
                        </button>
                      </div>
                    );
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              Now we'll add Counter component.
              <br /><br />
              This component will display the name and array of values received
              from properties. And a button that will call the onClick method
              that also received as a property of this component.
              <br /><br />
              Also on the screen you see buttonRef = React.createRef(), which we
              have not discussed yet, it will help us control the style
              properties of our button. <br />
              We will discuss this method in more detail later.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example</h4>
            <p>updating.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="9-30">
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  return (
                    &lt;>
                      &lt;Counter
                        value={this.state.counter1}
                        onClick={() =>
                          this.setState({
                            counter1: [...this.state.counter1, this.state.counter1.length + 1]
                          })
                        }
                        name={"counter 1"}
                      />
                      &lt;Counter
                        value={this.state.counter2}
                        onClick={() =>
                          this.setState({
                            counter2: [...this.state.counter2, this.state.counter2.length + 1]
                          })
                        }
                        name={"counter 2"}
                      />
                    &lt;/>
                  );
                }

                class Counter extends React.Component {
                  // Get box DOM reference
                  buttonRef = React.createRef();

                  render() {
                    console.log(`Rendering ${this.props.name}`);
                    return (
                      <div>
                        <h2>{this.props.name}:</h2>
                        <div>
                          {this.props.value.map((e, index) => (
                            <p key={index}>{e}</p>
                          ))}
                        </div>
                        <button ref={this.buttonRef} onClick={this.props.onClick}>
                          Add
                        </button>
                      </div>
                    );
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              Let's use our Counter component in the render method of
              UpdatingComponent.
              <br /><br />
              In the render method, we will add two counters that will use the
              values from the state to pass such properites as 'value' and
              'onClick' handler.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example</h4>
            <p>updating.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="37-39">
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  return (
                    &lt;>
                      &lt;Counter
                        value={this.state.counter1}
                        onClick={() =>
                          this.setState({
                            counter1: [...this.state.counter1, this.state.counter1.length + 1]
                          })
                        }
                        name={"counter 1"}
                      />
                      &lt;Counter
                        value={this.state.counter2}
                        onClick={() =>
                          this.setState({
                            counter2: [...this.state.counter2, this.state.counter2.length + 1]
                          })
                        }
                        name={"counter 2"}
                      />
                    &lt;/>
                  );
                }

                class Counter extends React.Component {
                  // Get box DOM reference
                  buttonRef = React.createRef();

                  shouldComponentUpdate(nextProps) {
                    return nextProps.value !== this.props.value
                  }

                  render() {
                    console.log(`Rendering ${this.props.name}`);
                    return (
                      <div>
                        <h2>{this.props.name}:</h2>
                        <div>
                          {this.props.value.map((e, index) => (
                            <p key={index}>{e}</p>
                          ))}
                        </div>
                        <button ref={this.buttonRef} onClick={this.props.onClick}>
                          Add
                        </button>
                      </div>
                    );
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              The preparatory part is over, let's start studying the methods
              that are present in the updating stage of the component lifecycle.
              <br /><br />
              Let's add <strong>shouldComponentUpdate</strong> <br /><br />
              This lifecycle method can be useful sometimes when you
              <strong
                >don't want React to render your state or prop changes</strong
              >. <br /><br />
              <strong>Anytime setState() is called</strong>, the component
              re-renders by default.<br /><br />
              The shouldComponentUpdate() method is used to let React know if a
              component <strong>is not affected by the state</strong> and prop
              changes. <br /><br />Keep in mind that this lifecycle method
              should be sparingly used, and it exists only for certain
              performance optimizations.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example</h4>
            <p>updating.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="41-46">
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  return (
                    &lt;>
                      &lt;Counter
                        value={this.state.counter1}
                        onClick={() =>
                          this.setState({
                            counter1: [...this.state.counter1, this.state.counter1.length + 1]
                          })
                        }
                        name={"counter 1"}
                      />
                      &lt;Counter
                        value={this.state.counter2}
                        onClick={() =>
                          this.setState({
                            counter2: [...this.state.counter2, this.state.counter2.length + 1]
                          })
                        }
                        name={"counter 2"}
                      />
                    &lt;/>
                  );
                }

                class Counter extends React.Component {
                  // Get box DOM reference
                  buttonRef = React.createRef();

                  shouldComponentUpdate(nextProps) {
                    return nextProps.value !== this.props.value
                  }

                  getSnapshotBeforeUpdate() {
                    // Let componentDidUpdate know whether to override the button color or not.
                    return {
                      overrideBoxColor: this.buttonRef.current.offsetTop > 500
                    };
                  }

                  render() {
                    console.log(`Rendering ${this.props.name}`);
                    return (
                      <div>
                        <h2>{this.props.name}:</h2>
                        <div>
                          {this.props.value.map((e, index) => (
                            <p key={index}>{e}</p>
                          ))}
                        </div>
                        <button ref={this.buttonRef} onClick={this.props.onClick}>
                          Add
                        </button>
                      </div>
                    );
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              Next method is getSnapshotBeforeUpdate.
              <br /><br />
              getSnapshotBeforeUpdate() is invoked right before the most
              recently rendered output is committed to e.g. the DOM.<br /><br />
              It enables your component to capture some information from the DOM
              (e.g. scroll position) before it is potentially changed.<br /><br />
              Any value returned by this lifecycle method will be
              <strong>passed as a parameter to componentDidUpdate()</strong>
              that we will look next.
              <br /><br />
              In our example, we look at how far our button is relative to the
              beginning of the screen. If the condition is true then we set
              overrideBoxColor to true.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example</h4>
            <p>updating.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="48-53">
                import React from "react";

                class UpdatingComponent extends React.Component {
                  state = {
                    counter1: [],
                    counter2: []
                  };

                  return (
                    &lt;>
                      &lt;Counter
                        value={this.state.counter1}
                        onClick={() =>
                          this.setState({
                            counter1: [...this.state.counter1, this.state.counter1.length + 1]
                          })
                        }
                        name={"counter 1"}
                      />
                      &lt;Counter
                        value={this.state.counter2}
                        onClick={() =>
                          this.setState({
                            counter2: [...this.state.counter2, this.state.counter2.length + 1]
                          })
                        }
                        name={"counter 2"}
                      />
                    &lt;/>
                  );
                }

                class Counter extends React.Component {
                  // Get box DOM reference
                  buttonRef = React.createRef();

                  shouldComponentUpdate(nextProps) {
                    return nextProps.value !== this.props.value
                  }

                  getSnapshotBeforeUpdate() {
                    // Let componentDidUpdate know whether to override the button color or not.
                    return {
                      overrideBoxColor: this.buttonRef.current.offsetTop > 500
                    };
                  }

                  componentDidUpdate(prevProps, prevState, snapshot) {
                    // Override the button ref directly
                    if (snapshot.overrideBoxColor) {
                      this.buttonRef.current.style.backgroundColor = "red";
                    }
                  }

                  render() {
                    console.log(`Rendering ${this.props.name}`);
                    return (
                      <div>
                        <h2>{this.props.name}:</h2>
                        <div>
                          {this.props.value.map((e, index) => (
                            <p key={index}>{e}</p>
                          ))}
                        </div>
                        <button ref={this.buttonRef} onClick={this.props.onClick}>
                          Add
                        </button>
                      </div>
                    );
                  }
                }

                export default UpdatingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              <strong> componentDidUpdate()</strong> - This lifecycle method is
              invoked as soon as the updating happens. <br /><br />
              The most common use case for the componentDidUpdate() method is
              updating the DOM in response to prop or state changes.
              <br /><br />
              On the screen you can see typical example of usage of this
              lifecycle method. We change the color of the button to red using
              snapshot.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">updating example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="2,4">
                import MountingComponent from "./mouning";
                import UpdatingComponent from "./updaing";

                export { MountingComponent, UpdatingComponent };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">updating example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4,18">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { MountingComponent, UpdatingComponent } from "./lifecycle";

                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      </div>
                      <br /> <br />
                      <div>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                      </div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">updating example</h4>
            <div>
              <iframe data-src="assets/videos/updating_example.mp4"></iframe>
            </div>
            <aside class="notes">
              As we can see, our component works exactly as we want it to.
            </aside>
          </section>
        </section>

        <!-- UNMOUNTING -->
        <section class="picture-slide">
          <h4 class="slide-name">unmounting</h4>
          <img
            src="assets/images/react_lifecycle_method_unmounting.png"
            alt="react_lifecycle_method_unmounting"
          />
          <aside class="notes">
            As you can see in the unmounting stage, we only have one method.
            <br /><br />
            Let's take a closer look at an example.
          </aside>
        </section>

        <!-- UNMOUNTING EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">unmounting example</h4>
            <div>
              <img
                src="assets/images/unmounting_example.png"
                alt="unmounting_example"
              />
              <ol>
                <li><strong>unmounting.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of unmounting lifecycle method.
              <br /><br />
              We will create
              <strong>unmounting.js</strong> inside lifecycle folder
              <br /><br />
              And now we ready to start coding our unmounting example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">unmounting example</h4>
            <p>unmounting.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                class UnmountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      date: new Date()
                    };
                  }

                  tick() {
                    this.setState({
                      date: new Date()
                    });
                  }

                  render() {
                    return <p>{this.state.date.toLocaleTimeString()}</p>;
                  }
                }

                export default UnmountingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              In the constructor, add a date to the state, which will be
              displayed in our component.<br /><br />And also add a tick method
              that will update the date in the component state to the current
              date.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">unmounting example</h4>
            <p>unmounting.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="17-25">
                import React from "react";

                class UnmountingComponent extends React.Component {
                  constructor(props) {
                    super(props);
                    this.state = {
                      date: new Date()
                    };
                  }

                  tick() {
                    this.setState({
                      date: new Date()
                    });
                  }

                  componentDidMount() {
                    this.timerID = setInterval(() => {
                      this.tick();
                    }, 1000);
                  }
                
                  componentWillUnmount() {
                    clearInterval(this.timerID);
                  }

                  render() {
                    return <p>{this.state.date.toLocaleTimeString()}</p>;
                  }
                }

                export default UnmountingComponent;               
					    </code>
            </pre>
            <aside class="notes">
              Let's add componentDidMount, which creates an interval that fires
              every second and calls the tick method.
              <br /><br />
              And finally, we will add componentWillUnmount with clearing
              interval call.
              <br /><br />
              As the name suggests this lifecycle method is called just before
              the component is unmounted and destroyed.
              <br /><br />If there are any cleanup actions that you would need
              to do, this would be the right spot Common cleanup activities
              performed in this method include, clearing timers, cancelling api
              calls, or clearing any caches in storage.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">unmounting example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="3-5">
                import MountingComponent from "./mouning";
                import UpdatingComponent from "./updaing";
                import UnmountingComponent from "./unmounting";

                export { MountingComponent, UpdatingComponent, UnmountingComponent };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">unmounting example - APP.JS</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4-8,23">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";

                export default function App() {
                  return (
                    &lt;div className="App">
                      <div>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      </div>
                      <br /> <br />
                      <div>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      </div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">unmounting example</h4>
            <div>
              <iframe data-src="assets/videos/unmounting_example.mp4"></iframe>
            </div>
            <aside class="notes">
              As we can see, our component works exactly as we want it to.
            </aside>
          </section>
        </section>

        <!-- HOOKS -->
        <section>
          <section class="bullets-slide">
            <h4 class="slide-name">hooks - motivation</h4>
            <ul>
              <li>It's hard to reuse stateful logic between components</li>
              <li>Complex components become hard to understand</li>
              <li>Classes confuse both people and machines</li>
            </ul>
            <aside class="notes">
              Hooks let us use state and other React features without writing a
              class.
              <br /><br />
              <strong>2 main points about hooks</strong>:<br />
              - There are no plans to remove classes from React.<br />
              - Hooks don't replace your knowledge of React concepts. Instead,
              Hooks provide a more direct API to the React concepts you already
              know props, state, context, refs, and lifecycle.
              <br /><br />
              On the slide you see 3 motivations why hooks were introduced.
              <br /><br />
              First, about <strong>sharing the business logic</strong>. Yes,
              with hooks, you can extract some component logic from a component
              so that it can be independently tested and reused. Hooks allow you
              to reuse stateful logic without changing the component hierarchy.
              This makes it easy to share hooks between many components or with
              the community. <br /><br />
              About second point. We can easy meet hard to maintain components
              that contains a number of <strong>lifecycle methods</strong> that
              often often contains a <strong>mix of unrelated logic</strong>.
              For example, components might perform some data fetching in
              componentDidMount and the same componentDidMount method might also
              contain some unrelated logic that sets up event listeners.
              Completely unrelated code combined in a single method. This makes
              it too easy to introduce bugs and inconsistencies. <br /><br />
              And about the last point. In addition to making code reuse and
              code organization more difficult, we've found that
              <strong>classes can be a large barrier</strong> to learning React.
              You have to understand how this works in JavaScript, which is very
              different from how it works in most languages. You have to
              remember to bind the event handlers. <br /><br />
              To solve these problems, Hooks let you use more of React's
              features without classes. Conceptually, React components have
              always been closer to functions.
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">hooks - basic examples</h4>
            <div>
              <p>State Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  const [state, setState] = useState(initialState);                
                </code>
              </pre>
            </div>
            <div>
              <p>Effect Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  useEffect(didUpdate);                  
                </code>
              </pre>
            </div>
            <div>
              <p>Callback Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  const memoizedCallback = useCallback(() => {
                    doSomething(a, b);
                  }, [a, b]);                                  
                </code>
              </pre>
            </div>
            <aside class="notes">
              Ok, let's start with the <strong>first one - state hook</strong>.
              It is the simplest one and post popular one. It returns a
              <strong>stateful value, and a function to update it</strong>.
              During the initial render, the returned state (state) is the same
              as the value passed as the first argument (initialState). The
              setState function is used to update the state. It accepts a new
              state value and starts a re-render of the component. <br /><br />
              Next hook is <strong>useEffect</strong>. The Effect Hook lets you
              <strong>perform side effects</strong> in function components Data
              fetching, setting up a subscription, and manually changing the DOM
              in React components are all examples of side effects. By using
              this Hook, you tell React that your component needs to do
              something after render. If your
              <strong>effect returns a function</strong>, React will run it when
              it is time to <strong>clean up</strong>. Also, you can tell React
              to skip applying an effect if certain values haven't changed
              between re-renders. To do so, pass an
              <strong>array as an optional second argument</strong> to
              useEffect.

              <br /><br />
              The React <strong>useCallback</strong> Hook returns a
              <strong>memoized callback function</strong>. Think of memoization
              as caching a value so that it does not need to be recalculated.
              This allows us to isolate resource intensive functions so that
              they will not automatically run on every render. The useCallback
              Hook only
              <strong>runs when one of its dependencies update</strong>. This
              can improve performance.
            </aside>
          </section>
          <section class="coding-and-picture-slide">
            <h4 class="slide-name">hooks - basic examples</h4>
            <div>
              <img src="assets/images/hooks_context.png" alt="hooks_context" />
              <div>
                <div>
                  <p>Context Hook</p>
                  <pre data-id="code-animation">
                  <code class="js" data-trim data-line-numbers>
                    const value = useContext(MyContext);
                  </code>
                </pre>
                </div>
              </div>
            </div>
            <aside class="notes">
              Next hook is <strong>useContext</strong> <br /><br />To illustrate
              the problem that this hook can solve, I want you to imagine
              <strong>many nested components</strong>. The component at the top
              and bottom of the stack <strong>need access to the state</strong>.
              To do this without Context, we will need to pass the state as
              "props" through each nested component. This is called "<strong
                >prop drilling</strong
              >". <br /><br />
              The solution is to create context. To create context, you must
              Import createContext and initialize it. Next we'll use the Context
              Provider to <strong>wrap the tree of components</strong> that need
              the state Context. Now, all components in this tree will have
              access to the user Context. <br /><br />
              And in order to use the Context in a child component, we need to
              <strong>access it using the useContext Hook</strong>.
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">hooks - basic examples</h4>
            <div>
              <p>Memo Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  const memoizedValue = useMemo(() => {
                    return computeExpensiveValue(a, b);
                  }, [a, b]);         
                </code>
              </pre>
            </div>
            <div>
              <p>Ref Hook</p>
              <pre data-id="code-animation">
                <code class="js" data-trim data-line-numbers>
                  const refContainer = useRef(initialValue);
                </code>
              </pre>
            </div>
            <div>
              <p>Other hooks: https://betterprogramming.pub/</p>
            </div>
            <aside class="notes">
              <strong>useMemo</strong> - Returns a
              <strong>memoized value</strong>. The useMemo Hook only runs when
              one of its <strong>dependencies update</strong>. This can improve
              performance. <br /><br />
              The useRef Hook allows you to persist values between renders. It
              can be used to store a
              <strong>
                mutable value that does not cause a re-render when updated </strong
              >. It can be used to
              <strong>access a DOM element directly</strong>.
            </aside>
          </section>
          <section class="text-slide">
            <h4 class="slide-name">hooks - rules</h4>
            <p>
              <strong>Only Call Hooks from React Functions</strong><br />
              Don't call Hooks from regular JavaScript functions.
            </p>
            <p>
              <strong>Only Call Hooks at the Top Level </strong><br />
              Don't call Hooks inside loops, conditions, or nested functions.
            </p>
            <aside class="notes">
              Two rules how we must use hooks.
              <br /><br />
              1. Don't call Hooks from regular JavaScript functions. Instead,
              you can:
              <strong>Call Hooks from React function components</strong>. Call
              Hooks from <strong>custom Hooks</strong> <br /><br />
              2. Don't call Hooks inside loops, conditions, or nested functions.
              Instead, always
              <strong>use Hooks at the top level of your React function</strong
              >, before any early returns. By following this rule, you ensure
              that Hooks are called in the same order each time a component
              renders.
            </aside>
          </section>
          <section class="text-slide">
            <h4 class="slide-name">hooks - custom hooks</h4>
            <p class="text-center-align">
              A custom Hook is a JavaScript function whose name starts with
              ”use” and that may call other Hooks.
            </p>
            <aside class="notes">
              Building your own Hooks lets you
              <strong>extract component logic into reusable functions</strong>.
              When we want to <strong>share logic</strong> between two
              JavaScript functions, we extract it to a third function. Both
              components and Hooks are functions, so this works for them too!
              <br /><br />
              Unlike a React component, a custom Hook doesn't need to have a
              specific signature. We can decide what it takes as arguments, and
              what, if anything, it should return. In other words, it's just
              like a normal function. Its
              <strong>name should always start with use</strong>. <br /><br />
              Let's look to the examples.
            </aside>
          </section>
        </section>

        <!-- USE-STATE EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useState example</h4>
            <div>
              <img
                src="assets/images/use_state_example.png"
                alt="use_state_example"
              />
              <ol>
                <li><strong>hooks</strong> folder</li>
                <li><strong>index.js</strong> file</li>
                <li><strong>use-state-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of useState hook.
              <br /><br />
              Firstly, we will create
              <strong>hooks</strong> folder inside src folder <br /><br />
              Next, we will create
              <strong>index.js</strong> inside hooks folder <br /><br />
              And the last, we will create
              <strong>use-state-component.js</strong> hooks lifecycle folder
              <br /><br />
              Now we ready to start coding our useState hook example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useState example</h4>
            <p>use-state-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                export const UseStateComponent = () => {
                  return (
                    <div>
                      <h2>Use state component</h2>
                      &lt;button onClick={() => {}}>Add&lt;/button>
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's create a simple UseStateComponent that will display a title
              and a button.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useState example</h4>
            <p>use-state-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,4,9-12">
                import React, { useState } from "react";

                export const UseStateComponent = () => {
                  const [counter, setCounter] = useState(0);

                  return (
                    <div>
                      <h2>Use state component</h2>
                      <div>{counter}</div>
                      &lt;button onClick={() => setCounter(counter + 1)}>
                        Add
                      &lt;/button>
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Now let's add state to our component.
              <br /><br />
              Let's make a counter that will increase when the button is clicked
              and add a display of the current value of our counter.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useState example</h4>
            <p>use-state-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="10">
                import React, { useState } from "react";

                export const UseStateComponent = () => {
                  const [counter, setCounter] = useState(0);

                  return (
                    <div>
                      <h2>Use state component</h2>
                      <div>{counter}</div>
                      &lt;button onClick={() => setCounter((prevCount) => prevCount + 1)}>
                        Add
                      &lt;/button>
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              We also can set state in this way. <br /><br />
              Pass an anonymous function that will take the current value and
              return the new one.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useState example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import { UseStateComponent } from "./use-state-component";

                export {
                  UseStateComponent
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useState example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="9-11,13,18,24,30-33">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
              <br /><br />
              We've also added a few styles to the divs to separate the examples
              a bit.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useState example</h4>
            <div>
              <iframe data-src="assets/videos/use_state_example.mp4"></iframe>
            </div>
            <aside class="notes">
              As we can see, our component works exactly as we want it to.
            </aside>
          </section>
        </section>

        <!-- USE-EFFECT EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useEffect example</h4>
            <div>
              <img
                src="assets/images/use_effect_example.png"
                alt="use_effect_example"
              />
              <ol>
                <li><strong>use-effect-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of useEffect hook.
              <br /><br />
              We will create
              <strong>use-effect-component.js</strong> hooks lifecycle folder
              <br /><br />
              Now we ready to start coding our useEffect hook example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useEffect example</h4>
            <p>use-effect-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState } from "react";

                export const UseEffectComponent = () => {
                  const [title, setTitle] = useState("Title");

                  return (
                    <div>
                      <h2>Use effect component</h2>
                      <div>{title}</div>
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's create a UseEffectComponent that will have a component title
              and also display the title value from the state.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useEffect example</h4>
            <p>use-effect-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,6-13">
                import React, { useState, useEffect } from "react";

                export const UseEffectComponent = () => {
                  const [title, setTitle] = useState("Title");

                  useEffect(() => {
                    console.log("Fetch data...");
                    setTimeout(() => setTitle("New title"), 3000);

                    return () => {
                      console.log("remove listeners and etc.");
                    };
                  }, []);

                  return (
                    <div>
                      <h2>Use effect component</h2>
                      <div>{title}</div>
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              It's time to add useEffect.
              <br /><br />
              Let's add it to our component, it will fire when the component is
              mounted, it will call the console.log, set a timeout of 3 seconds
              to change the title.
              <br /><br />
              Also, this hook will return a function for cleaning in which a
              message will be displayed on the console.log.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useEffect example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="2,6">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";

                export {
                  UseStateComponent,
                  UseEffectComponent
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useEffect example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="11,34">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useEffect example</h4>
            <div>
              <iframe data-src="assets/videos/use_effect_example.mp4"></iframe>
            </div>
            <aside class="notes">
              As we can see, our component works exactly as we want it to.
            </aside>
          </section>
        </section>

        <!-- USE-CALLBACK EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useCallback example</h4>
            <div>
              <img
                src="assets/images/use_callback_example.png"
                alt="use_callback_example"
              />
              <ol>
                <li><strong>use-callback-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of useCallback hook.
              <br /><br />
              We will create
              <strong>use-callback-component.js</strong> hooks lifecycle folder
              <br /><br />
              Now we ready to start coding our useCallback hook example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useCallback example</h4>
            <p>use-callback-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState } from "react";

                export const UseCallbackComponent = () => {
                  const [count, setCount] = useState(0);
                  const [items, setItems] = useState([]);

                  return (
                    &lt;>
                      <h2>Use callback component</h2>
                      <br />
                      <div>
                        <span>Count: {count}</span>
                        &lt;button onClick={() => {}}>+&lt;/button>
                      </div>
                    &lt;/>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's create a UseCallbackComponent component that will hold two
              states, display a title and have a button.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useCallback example</h4>
            <p>use-callback-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,10,20-25">
                import React, { useState, memo } from "react";

                export const UseCallbackComponent = () => {
                  const [count, setCount] = useState(0);
                  const [items, setItems] = useState([]);

                  return (
                    &lt;>
                      <h2>Use callback component</h2>
                      &lt;MemoComponent onClick={() => {}} />
                      <br />
                      <div>
                        <span>Count: {count}</span>
                          &lt;button onClick={() => {}}>+&lt;/button>
                      </div>
                    &lt;/>
                  );
                };

                const InnerComponent = ({ onClick }) => {
                  console.log("child render");
                  return &lt;button onClick={onClick}>Button&lt;/button>;
                };

                const MemoComponent = memo(InnerComponent);
					    </code>
            </pre>
            <aside class="notes">
              Below we will add another InnerComponent component that will
              contain the message output to the console.log, display the button
              and handle clicks using the method obtained from the properties.
              <br /><br />
              As you can see, we are using the memo method for this component.
              The memo creates a memoized component and if the component
              properties do not change, then the component is not rerendered.
              <br /><br />
              Memo usage is really important thing in this example.
              <br /><br />
              We will also add a new component to our UseCallbackComponent.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useCallback example</h4>
            <p>use-callback-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,7-13,18,22">
                import React, { useState, useCallback, memo } from "react";

                export const UseCallbackComponent = () => {
                  const [count, setCount] = useState(0);
                  const [items, setItems] = useState([]);

                  const increment = () => {
                    setCount((c) => c + 1);
                  };

                  const handleClick = useCallback(() => {
                    setItems(() => [...items, "New item"]);
                  }, [items]);

                  return (
                    &lt;>
                      <h2>Use callback component</h2>
                      &lt;MemoComponent onClick={handleClick} />
                      <br />
                      <div>
                        <span>Count: {count}</span>
                        <button onClick={increment}>+</button>
                      </div>
                    &lt;/>
                  );
                };

                const InnerComponent = ({ onClick }) => {
                  console.log("child render");
                  return <button onClick={onClick}>Button</button>;
                };

                const MemoComponent = memo(InnerComponent);
					    </code>
            </pre>
            <aside class="notes">
              Now let's create two functions increment and handleClick. The
              first will change the state of the count and increase it by one.
              The second will change the state of the items and add a new item
              there.
              <br /><br />
              As you can see, for the second function we used useCallback.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useCallback example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="3,8">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useCallback example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="12,36">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useEffect example</h4>
            <div>
              <iframe
                data-src="assets/videos/use_callback_example_1.mp4"
              ></iframe>
            </div>
            <aside class="notes">
              As we can see, our component works exactly as we want it to.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useCallback example</h4>
            <p>use-callback-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="11-13">
                import React, { useState, useCallback, memo } from "react";

                export const UseCallbackComponent = () => {
                  const [count, setCount] = useState(0);
                  const [items, setItems] = useState([]);

                  const increment = () => {
                    setCount((c) => c + 1);
                  };

                  const handleClick = () => {
                    setItems(() => [...items, "New item"]);
                  }

                  return (
                    &lt;>
                      <h2>Use callback component</h2>
                      &lt;MemoComponent onClick={handleClick} />
                      <br />
                      <div>
                        <span>Count: {count}</span>
                        <button onClick={increment}>+</button>
                      </div>
                    &lt;/>
                  );
                };

                const InnerComponent = ({ onClick }) => {
                  console.log("child render");
                  return <button onClick={onClick}>Button</button>;
                };

                const MemoComponent = memo(InnerComponent);
					    </code>
            </pre>
            <aside class="notes">
              Let's try without useCallback. We are using memo, so the
              InnerComponent component should not re-render since onClick is not
              changing.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useCallback example</h4>
            <div>
              <iframe
                data-src="assets/videos/use_callback_example_2.mp4"
              ></iframe>
            </div>
            <aside class="notes">
              Why it is rerendered? This is because of every time a component
              re-renders, its functions get recreated.
            </aside>
          </section>
        </section>

        <!-- USE-CONTEXT EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useContext example</h4>
            <div>
              <img
                src="assets/images/use_context_example.png"
                alt="use_context_example"
              />
              <ol>
                <li><strong>use-context-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of useContext hook.
              <br /><br />
              We will create
              <strong>use-context-component.js</strong> hooks lifecycle folder
              <br /><br />
              Now we ready to start coding our useContext hook example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useContext example</h4>
            <p>use-context-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                const themes = {
                  blue: {
                    textColor: "blue"
                  },
                  red: {
                    textColor: "red"
                  }
                };

                export const UseContextComponent = () => {
                  return (
                    &lt;>
                      &lt;InnerComponent />
                    &lt;/>
                  );
                };

                const InnerComponent = () => {
                  return (
                    <div>
                      <h2>Use context component</h2>
                      &lt;p>Themed text&lt;/p>
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's create two components. <br /><br />The first InnerComponent
              will render the two text fields. <br /><br />The second
              UseContextComponent will render the first one. <br /><br />
              And also create an object containing two thems, blue and red.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useContext example</h4>
            <p>use-context-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,12, 16,18,23,28">
                import React, { useContext } from "react";

                const themes = {
                  blue: {
                    textColor: "blue"
                  },
                  red: {
                    textColor: "red"
                  }
                };

                const ThemeContext = React.createContext(themes.blue);

                export const UseContextComponent = () => {
                  return (
                    &lt;ThemeContext.Provider value={themes.red}>
                      &lt;InnerComponent />
                    &lt;/ThemeContext.Provider>
                  );
                };

                const InnerComponent = () => {
                  const theme = useContext(ThemeContext);

                  return (
                    <div>
                      <h2>Use context component</h2>
                      &lt;p style={{ color: theme.textColor }}>Themed text&lt;/p>
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Now we are faced with the task of throwing the value of the
              current theme into the inner component from the outer one, without
              using the properties, but using the context.
              <br /><br />
              To do this, we will create a context on line 12 and specify the
              default value. Next, in the UseContextComponent component, we will
              use the created context and take the provider from it.
              <br /><br />
              In the InnerComponent, all that's left is to get the context and
              use it to change the color.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useContext example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="4,10">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";
                import { UseContextComponent } from "./use-context-component";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useContext example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="13,38">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="picture-slide">
            <h4 class="slide-name">useContext example</h4>
            <img
              src="assets/images/use_context_example_result.png"
              class="with-border"
              alt="use_context_example_result"
            />
            <aside class="notes">
              As you can see our example works and we were able to pass the
              theme value to the inner component without using prop drilling.
            </aside>
          </section>
        </section>

        <!-- USE-MEMO EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useMemo example</h4>
            <div>
              <img
                src="assets/images/use_memo_example.png"
                alt="use_memo_example"
              />
              <ol>
                <li><strong>use-memo-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of useMemo hook.
              <br /><br />
              We will create
              <strong>use-memo-component.js</strong> hooks lifecycle folder
              <br /><br />
              Now we ready to start coding our useMemo hook example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useMemo example</h4>
            <p>use-memo-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState } from "react";

                export const UseMemoComponent = () => {
                  return (
                    &lt;>
                      <h2>Use memo component</h2>
                      &lt;InnerComponent value={30} />
                    &lt;/>
                  );
                };

                const InnerComponent = ({ value }) => {
                  const [count, setCount] = useState(0);

                  const calculated = 20;

                  return (
                    &lt;>
                      <p>Count: {count}</p>
                      <p>Calculated: {calculated}</p>
                      &lt;button onClick={() => setCount((c) => c + 1)}>Button&lt;/button>
                    &lt;/>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's create two components. The first InnerComponent will accept
              values through properties, store the state of the count, will
              display the count, the magic value of the calculated, and also
              have a button to increase the count.
              <br /><br />
              And the second component is UseMemoComponent, which will deal
              exclusively with rendering the first one.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useMemo example</h4>
            <p>use-memo-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,15-18">
                import React, { useState, useMemo } from "react";

                export const UseMemoComponent = () => {
                  return (
                    &lt;>
                      <h2>Use memo component</h2>
                      &lt;InnerComponent value={30} />
                    &lt;/>
                  );
                };

                const InnerComponent = ({ value }) => {
                  const [count, setCount] = useState(0);

                  const calculated = useMemo(() => {
                    console.log("some calculations here");
                    return value * 2;
                  }, [value]);

                  return (
                    &lt;>
                      <p>Count: {count}</p>
                      <p>Calculated: {calculated}</p>
                      &lt;button onClick={() => setCount((c) => c + 1)}>Button&lt;/button>
                    &lt;/>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Now is the time to implement calculated. It will be evaluated
              using a very complex formula and will be wrapped in a useMemo to
              avoid recalculation if value has not changed.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useMemo example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="5,12">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";
                import { UseContextComponent } from "./use-context-component";
                import { UseMemoComponent } from "./use-memo-component";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useMemo example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="14,40">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useMemo example</h4>
            <div>
              <iframe data-src="assets/videos/use_memo_example_1.mp4"></iframe>
            </div>
            <aside class="notes">
              Our component works fine and when the count changes, our value is
              not recalculated.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useMemo example</h4>
            <p>use-memo-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="15-18">
                import React, { useState, useMemo } from "react";

                export const UseMemoComponent = () => {
                  return (
                    &lt;>
                      <h2>Use memo component</h2>
                      &lt;InnerComponent value={30} />
                    &lt;/>
                  );
                };

                const InnerComponent = ({ value }) => {
                  const [count, setCount] = useState(0);

                  const calculated = (() => {
                    console.log("some calculations here");
                    return value * 2;
                  })();

                  return (
                    &lt;>
                      <p>Count: {count}</p>
                      <p>Calculated: {calculated}</p>
                      &lt;button onClick={() => setCount((c) => c + 1)}>Button&lt;/button>
                    &lt;/>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Now let's try without oseMeto and see what the difference is.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useMemo example</h4>
            <div>
              <iframe data-src="assets/videos/use_memo_example_2.mp4"></iframe>
            </div>
            <aside class="notes">
              As we can see, every time we change the count, we recalculate our
              value, although the value has not changed and there is no point in
              recalculating it.
            </aside>
          </section>
        </section>

        <!-- USE-REF EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">useRef example</h4>
            <div>
              <img
                src="assets/images/use_ref_example.png"
                alt="use_ref_example"
              />
              <ol>
                <li><strong>use-ref-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of useRef hook.
              <br /><br />
              We will create
              <strong>use-ref-component.js</strong> hooks lifecycle folder
              <br /><br />
              Now we ready to start coding our useRef hook example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useRef example</h4>
            <p>use-ref-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState } from "react";

                export const UseRefComponent = () => {
                  const [inputValue, setInputValue] = useState("");

                  return (
                    &lt;>
                      <h2>Use Ref component</h2>
                      &lt;input
                        type="text"
                        value={inputValue}
                        onChange={(e) => setInputValue(e.target.value)}
                      />
                    &lt;/>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's create a UseRefComponent component, it will store the state
              and the text input field, which will change this state.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useRef example</h4>
            <p>use-ref-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,5,7-9,19">
                import React, { useState, useEffect, useRef } from "react";

                export const UseRefComponent = () => {
                  const [inputValue, setInputValue] = useState("");
                  const count = useRef(0);

                  useEffect(() => {
                    count.current = count.current + 1;
                  });

                  return (
                    &lt;>
                      <h2>Use Ref component</h2>
                      &lt;input
                        type="text"
                        value={inputValue}
                        onChange={(e) => setInputValue(e.target.value)}
                      />
                      <h1>Render Count: {count.current}</h1>
                    &lt;/>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Now let's try to count how many times this component is
              rendered.<br /><br />
              To do this, we will create a ref and increase it in the effect.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">useRef example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="6,14">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";
                import { UseContextComponent } from "./use-context-component";
                import { UseMemoComponent } from "./use-memo-component";
                import { UseRefComponent } from "./use-ref-component";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">useRef example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="15,42">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">useRef example</h4>
            <div>
              <iframe data-src="assets/videos/use_ref_example.mp4"></iframe>
            </div>
            <aside class="notes">
              As you can see our component works fine. <br /><br />
              It successfully counts the number of renderers. <br /><br />
              Renderers work only if the state changes, if the value of the ref
              changes, then the rerender does not start.
            </aside>
          </section>
        </section>

        <!-- CUSTOM HOOK EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">custom hook example</h4>
            <div>
              <img
                src="assets/images/custom_hook_example.png"
                alt="custom_hook_example"
              />
              <ol>
                <li><strong>use-custom-hook-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of custom hook.
              <br /><br />
              We will create
              <strong>use-custom-hook-component.js</strong> hooks lifecycle
              folder <br /><br />
              Now we ready to start coding our custom hook example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">custom hook</h4>
            <p>use-custom-hook-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                export const UseCustomHookComponent = () => {
                  const { data, loading } = {
                    loading: false,
                    data: null
                  }

                  return (
                    <div>
                      <h2>Use custom hook component</h2>
                      {loading && <p>Loading</p>}
                      {data && <div>{data}</div>}
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's create a UseCustomHookComponent that will display the
              loading indicator and some date.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">custom hook</h4>
            <p>use-custom-hook-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,3-16,19">
                import React, { useState, useEffect } from "react";

                const useData = () => {
                  const [data, setData] = useState();
                  const [loading, setLoading] = useState(true);

                  useEffect(() => {
                    console.log("Fetch custom hook data ...");
                    setTimeout(() => {
                      setData("data");
                      setLoading(false);
                    }, 3000);
                  }, []);

                  return { data, loading };
                };

                export const UseCustomHookComponent = () => {
                  const { data, loading } = useData();

                  return (
                    <div>
                      <h2>Use custom hook component</h2>
                      {loading && <p>Loading</p>}
                      {data && <div>{data}</div>}
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              <br /><br />
              Now it's time to create our first custom hook, which will simulate
              a real request to the server to get data.
              <br /><br />
              Therefore, in the first lines, we will create two states to store
              the loading indicator and data. And in the effect we will simulate
              a request to the server with a delay.
              <br /><br />
              Notice how we named our hook and how easy it is to use.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">custom hook</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="7,16">
                import { UseStateComponent } from "./use-state-component";
                import { UseEffectComponent } from "./use-effect-component";
                import { UseCallbackComponent } from "./use-callback-component";
                import { UseContextComponent } from "./use-context-component";
                import { UseMemoComponent } from "./use-memo-component";
                import { UseRefComponent } from "./use-ref-component";
                import { UseCustomHookComponent } from "./use-custom-hook-component.js";

                export {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">custom hook example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="16,44">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">custom hook example</h4>
            <div>
              <iframe data-src="assets/videos/custom_hook_example.mp4"></iframe>
            </div>
            <aside class="notes">As you can see, everything works great.</aside>
          </section>
        </section>

        <!-- ADDITIONAL MATERIALS -->
        <section class="video-text-slide">
          <h4 class="slide-name">Additional materials</h4>
          <div>
            <div>
              <a
                href="https://www.youtube.com/watch?v=dpw9EHDh2bM
              "
                target="_blank"
                >React Today and Tomorrow
              </a>
              <iframe
                src="https://www.youtube.com/embed/dpw9EHDh2bM"
                title="React Today and Tomorrow"
                allowfullscreen
              >
              </iframe>
            </div>
            <div>
              <p>
                <strong>Sophie Alpert</strong> - manage the react core team at
                Facebook;
                <br />
                <strong>Dan Abramov</strong> - works at react team;
                <br />
                <strong>Ryan Florence</strong> - was involved to the developing
                of several react libraries.
              </p>
              <p>
                - Why react is more popular then other stuff and what problems
                he has;
                <br />
                - How hooks can help us to solve those problems;
                <br />
                - Why we should rewrite our apps with hooks.
              </p>
            </div>
          </div>
          <aside class="notes">
            The first three talks from React Conf 2018 by Sophie Alpert, Dan
            Abramov, and Ryan Florence.
            <br /><br />
            Third speaker with show how hooks feel in a little bit more
            real-world use case.
          </aside>
        </section>

        <!-- HOC-s -->
        <section class="text-and-conding-slide">
          <h4 class="slide-name">HOC-s</h4>
          <div class="center-align">
            <p>
              HOC is a function that takes a component and returns a new
              component
            </p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
							const EnhancedComponent = withHoc(WrappedComponent); 
						</code>
					</pre>
          </div>
          <aside class="notes">
            A higher-order component (HOC) is an advanced technique in React for
            reusing component logic. Components are the primary unit of code
            reuse in React.
            <br /><br />
            HOC doesn't modify the input component, nor does it use inheritance
            to copy its behavior. Rather, a HOC <strong>composes</strong> the
            original component by <strong>wrapping</strong> it in a container
            component. A HOC is a pure function with zero side-effects.
            <br /><br />
            The wrapped component receives all the props of the container, along
            with a new prop, <strong>data</strong>, which it uses to render its
            output.
          </aside>
        </section>

        <!-- HOC EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">HOC example</h4>
            <div>
              <img src="assets/images/hoc_example.png" alt="hoc_example" />
              <ol>
                <li><strong>hoc</strong> folder</li>
                <li><strong>index.js</strong> file</li>
                <li><strong>hoc-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of hoc.
              <br /><br />
              Firstly, we will create
              <strong>hoc</strong> folder inside src folder <br /><br />
              Next, we will create
              <strong>index.js</strong> inside hoc folder <br /><br />
              And the last, we will create
              <strong>hoc-component.js</strong> hoc folder <br /><br />
              Now we ready to start coding our hoc example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">HOC example</h4>
            <p>hoc-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React from "react";

                const _HocComponent = (props) => {
                  return (
                    <div>
                      <h2>With HOC component</h2>
                      <p>Is internet reachable</p>
                    </div>
                  );
                };
					    </code>
            </pre>
            <aside class="notes">
              Let's create a _HocComponent component that will take care of
              displaying the current state of the internet connection.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">HOC example</h4>
            <p>hoc-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,3-17,20,25,30">
                import React, { useState, useEffect } from "react";

                const withInternetCheck = (Component) => (props) => {
                  const [isInternetReachable, setIsInternetReachable] = useState(false);

                  useEffect(() => {
                    console.log("Check internet...");
                    setTimeout(() => setIsInternetReachable(true), 7000);
                  }, []);

                  return (
                    &lt;>
                      {!isInternetReachable && <p>No internet</p>}
                      &lt;Component injectedProp={isInternetReachable} {...props} />
                    &lt;/>
                  );
                };

                const _HocComponent = (props) => {
                  const { injectedProp } = props;

                  return (
                    <div>
                      <h2>With HOC component</h2>
                      <p>Is internet reachable: {`${injectedProp}`}</p>
                    </div>
                  );
                };

                export const HocComponent = withInternetCheck(_HocComponent);
					    </code>
            </pre>
            <aside class="notes">
              And now let's add our hook, which will enrich the received
              component and add an injectedProp property to it, which will store
              the current state of the internet connection.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">HOC example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import { HocComponent } from "./hoc-component";

                export { HocComponent };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">HOC example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="18,48-51">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";
                import { HocComponent } from "./hoc";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>HOCs</h1>
                        &lt;HocComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">HOC example</h4>
            <div>
              <iframe data-src="assets/videos/hoc_example.mp4"></iframe>
            </div>
            <aside class="notes">
              As we can see, our component successfully copes with the task of
              displaying the current state of the Internet connection.
            </aside>
          </section>
        </section>

        <!-- CONTROLLED COMPONENTS -->
        <section class="picture-slide">
          <h4 class="slide-name">Controlled component</h4>
          <img
            src="assets/images/controlled_components.png"
            alt="controlled_components"
          />
          <aside class="notes">
            Controlled vs uncontrolled components
            <br /><br />
            Let's start with controlled components.<br />
            As the name says, in the controlled component the form input
            element's values and mutations are totally
            <strong>driven by event handlers</strong> and the value of the input
            element is always <strong>inferred from the state</strong>. Here's a
            flow diagram of a controlled component <br /><br />
            Let's understand the two most important aspects of controlled
            components<br />
            * The component has the <strong>value</strong> attribute set as the
            components <strong>state</strong>. This is very important so that
            <strong>the input</strong> component's value will always be in sync
            with the components state value.<br />
            * Secondly, we are handling the change event emitted by the element
            whenever a user tries to update the element's value.
            <strong>Inside the handler function</strong>, we are
            <strong>mutating the state</strong> with the updated input value.<br />
          </aside>
        </section>

        <!-- CONTROLLED EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">Controlled component example</h4>
            <div>
              <img
                src="assets/images/controlled_component_example.png"
                alt="controlled_component_example"
              />
              <ol>
                <li><strong>controlled-uncontrolled</strong> file</li>
                <li><strong>index.js</strong> file</li>
                <li><strong>controlled-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of Controlled component.
              <br /><br />
              Firstly, we will create
              <strong>controlled-uncontrolled</strong> folder inside src folder
              <br /><br />
              Next, we will create
              <strong>controlled-component.js</strong> inside
              controlled-uncontrolled folder <br /><br />
              And the last, we will create
              <strong>index.js</strong> controlled-uncontrolled folder
              <br /><br />
              Now we ready to start coding our Controlled component example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Controlled component example</h4>
            <p>controlled-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState } from "react";

                const ControlledComponent = () => {
                  const [name, setName] = useState("");
                  const [email, setEmail] = useState("");

                  console.log("render ControlledComponent");

                  const onSubmit = () => {
                    console.log("Name value: " + name);
                    console.log("Email value: " + email);
                  };

                  return (
                    <div>
                      <h3>Controlled Component</h3>
                      &lt;form onSubmit={onSubmit}>
                        &lt;input
                          type="text"
                          name="name"
                          value={name}
                          onChange={(e) => setName(e.target.value)}
                          required
                        />
                        &lt;input
                          type="email"
                          name="email"
                          value={email}
                          onChange={(e) => setEmail(e.target.value)}
                          required
                        />
                        <input type="submit" value="Submit" />
                      &lt;/form>
                    </div>
                  );
                };

                export default ControlledComponent;
					    </code>
            </pre>
            <aside class="notes">
              In this example, we will create an example of a controlled
              component that will store values in states, will have a form and
              two text fields. And of course the onSubmit method.
              <br /><br />
              Let's also add a console.log to keep track of how many times our
              component is rendered.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Controlled component example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import ControlledComponent from "./controlled-component";

                export { ControlledComponent };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">Controlled component example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="19,53-57">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";
                import { HocComponent } from "./hoc";
                import { ControlledComponent } from "./controlled-uncontrolled";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>HOCs</h1>
                        &lt;HocComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Controlled and uncontrolled components</h1>
                        &lt;ControlledComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">Controlled component example</h4>
            <div>
              <iframe
                data-src="assets/videos/controlled_component_example.mp4"
              ></iframe>
            </div>
            <aside class="notes">
              As we can see our component works, however every time our entire
              form is re-rendered.
              <br /><br />
              This problem can be solved quite easily if each of the text fields
              is taken out into separate components with its own state.
              <br />
              However, for our example, this is not so important, let's now talk
              about uncontrolled components.
            </aside>
          </section>
        </section>

        <!-- UNCONTROLLED COMPONENTS -->
        <section class="picture-slide">
          <h4 class="slide-name">UNCONTROLLED COMPONENTS</h4>
          <img
            src="assets/images/uncontrolled_components.png"
            alt="uncontrolled_components"
          />
          <aside class="notes">
            How uncontrolled components work?
            <br /><br />
            They <strong>don't use any states</strong> on input elements
            <strong>or any event handler</strong>. This type of component
            <strong>doesn't care</strong> about an input element's
            <strong>real-time value changes</strong>. <br /><br />
            In the uncontrolled components, we use Refs to access the values of
            input elements.
            <br /><br />
            Why Controlled vs uncontrolled components are required?<br />
            React provides both a model-view approach with controlled components
            and an only view approach using uncontrolled components. <br />
            While other frameworks like Angular or VueJs provide only Model-View
            two-way binding approach to the same use case, React provides two
            distinctively flexible solutions. <br /><br />
            It depends on the use cases about how and where one would use any of
            those.
          </aside>
        </section>

        <!-- UNCONTROLLED EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">Uncontrolled component example</h4>
            <div>
              <img
                src="assets/images/uncontrolled_component_example.png"
                alt="uncontrolled_component_example"
              />
              <ol>
                <li><strong>uncontrolled-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of Uncontrolled component.
              <br /><br />
              We will create
              <strong>uncontrolled-component.js</strong> inside
              controlled-uncontrolled folder <br /><br />
              <br /><br />
              Now we ready to start coding our Uncontrolled component example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Uncontrolled component example</h4>
            <p>uncontrolled-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useRef } from "react";

                const UncontrolledComponent = () => {
                  const nameRef = useRef();
                  const emailRef = useRef();

                  console.log("render UncontrolledComponent");

                  const onSubmit = () => {
                    console.log("Name value: " + nameRef.current.value);
                    console.log("Email value: " + emailRef.current.value);
                  };

                  return (
                    <div>
                      <h3>Uncontrolled Component</h3>
                      &lt;form onSubmit={onSubmit}>
                        &lt;input type="text" name="name" ref={nameRef} required />
                        &lt;input type="email" name="email" ref={emailRef} required />
                        &lt;input type="submit" value="Submit" />
                      &lt;/form>
                    </div>
                  );
                };

                export default UncontrolledComponent;
					    </code>
            </pre>
            <aside class="notes">
              In this example, we will create an example of an uncontrolled
              component. And we will receive the value through refs in the
              onSubmit method.
              <br /><br />
              Let's also add a console.log to keep track of how many times our
              component is rendered.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Uncontrolled component example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="2,4">
                import ControlledComponent from "./controlled-component";
                import UncontrolledComponent from "./uncontrolled-component";

                export { ControlledComponent, UncontrolledComponent };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">Uncontrolled component example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="19-22,60">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";
                import { HocComponent } from "./hoc";
                import {
                  ControlledComponent,
                  UncontrolledComponent
                } from "./controlled-uncontrolled";

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>HOCs</h1>
                        &lt;HocComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Controlled and uncontrolled components</h1>
                        &lt;ControlledComponent />
                        &lt;UncontrolledComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">Uncontrolled component example</h4>
            <div>
              <iframe
                data-src="assets/videos/controlled_component_example.mp4"
              ></iframe>
            </div>
            <aside class="notes">
              As we can see our component works perfectly.
            </aside>
          </section>
        </section>

        <!-- RECONCILIATION -->
        <section>
          <section class="text-slide">
            <h4 class="slide-name">Reconciliation</h4>
            <p>
              DOM operations are heavy -> Virtual DOM
              <br /><br /><br />
              To <strong>diff update tree with previous</strong> tree to
              determine which parts need to be changed. <br /><br /><br />
              Virtual DOM -> rendering environment -> update (changing state) ->
              reconciliation (new tree diffed with the old one) -> update
              rendering environment
            </p>
            <aside class="notes">
              When you use React, at a single point in time you can think of the
              <strong
                >render() function as creating a tree of React elements.</strong
              >
              <br />
              <br />
              On the next state or props update, that
              <strong>render()</strong> function
              <strong>will return a different tree of React elements</strong>.
              <br />
              React then needs to figure out how to efficiently update the UI to
              match the most recent tree.
              <br /><br />
              Let's start with Virtual DOM, this is a
              <strong>representation in the form of an object</strong> of the
              state of our application and through the libraries it matches to
              the browser-DOM or react-native.<br />
              DOM operations are very heavy and modifying objects is very
              easy.<br />
              Rendering takes place in two stages Reconciling and updating.
              <br /><br />
              Reconciliation is when <strong>two trees are taken</strong>,
              <strong>compared</strong> and it determines which parts of this
              tree <strong>have changed and should be redrawn</strong>.
              <br /><br />
              There is one typical picture of how our application rerenders.<br />
              There is a virtual DOM that is re-rendered to the environment,
              this is a react-DOM or a react-native, changes occur and the
              virtual-DOM changes, a re-enforcement occurs, a new tree is
              compared with the old one and an IU upgrade occurs.
            </aside>
          </section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">two assumptions for reconciliation</h4>
            <div>
              <img
                src="assets/images/reconcilation_assumptions.png"
                alt="reconcilation_assumptions"
              />
              <ol>
                <li>
                  Two elements of different types will produce
                  <strong>different trees.</strong>
                </li>
                <li>
                  The developer can hint at which child elements may
                  <strong>be stable</strong> across different renders with a key
                  prop.
                </li>
              </ol>
            </div>
            <aside class="notes">
              For the algorithm to work quickly, there are two assumptions that
              are most often equal.
              <br /><br />
              1.<br />
              When comparing two trees, React first compares the two root
              elements. <br />
              Whenever the root elements have <strong>different types</strong>,
              React will tear
              <strong>down the old tree and build the new</strong> tree from
              scratch.<br />
              When tearing down a tree, old DOM nodes are destroyed. Component
              instances receive componentWillUnmount().
              <br /><br />
              When comparing two React DOM elements of the
              <strong>same type</strong>, React
              <strong>looks at the attributes</strong> of both, keeps the same
              underlying DOM node, and only updates the changed attributes.
              <br /><br />
              2. Second assumption is about using KEYS.
              <br /><br />
              Recursing On Children<br />
              By default, when recursing on the children of a DOM node, React
              just iterates over both lists of children at the same time and
              generates a mutation whenever there's a difference.<br />
              If you implement it naively, inserting an element at the beginning
              has worse performance.<br />
              In order to solve this issue, React supports a
              <strong>key</strong> attribute. <br />
              When children have keys, React uses the key to match children in
              the original tree with children in the subsequent tree.
            </aside>
          </section>
        </section>

        <!-- RECONCILIATION EXAMPLE -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">reconciliation example</h4>
            <div>
              <img
                src="assets/images/reconciliation_example.png"
                alt="reconciliation_example"
              />
              <ol>
                <li><strong>reconciliation</strong> folder</li>
                <li><strong>index.js</strong> folder</li>
                <li><strong>reconciliation-component.js</strong> file</li>
              </ol>
            </div>
            <aside class="notes">
              Let's make an example of reconciliation.
              <br /><br />
              Firstly, we will create
              <strong>reconciliation</strong> folder inside src folder
              <br /><br />
              Next, we will create
              <strong>reconciliation-component.js</strong> inside reconciliation
              folder <br /><br />
              And the last, we will create
              <strong>index.js</strong> reconciliation folder <br /><br />
              Now we ready to start coding our reconciliation example
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Reconciliation example</h4>
            <p>reconciliation-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState, useEffect, memo } from "react";

                const ReconciliationComponent = () => {
                  const [items, setItems] = useState([
                    { name: "item 1", key: "item_1" },
                    { name: "item 30", key: "item_30" },
                    { name: "item 70", key: "item_70" },
                    { name: "item 130", key: "item_130" }
                  ]);

                  const handleAddToTop = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  const handleAddToBottom = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  return (
                    &lt;>
                      &lt;button onClick={handleAddToTop}>Add to top&lt;/button>
                      &lt;button onClick={handleAddToBottom}>Add to bottom&lt;/button>
                    &lt;/>
                  );
                };

                const _InnerComponent = ({ name }) => {
                  useEffect(() => () => {
                      console.log(`unmount inner component: ${name}`);
                    },
                    [name]
                  );

                  return <p>Inner component {name}</p>;
                };

                const InnerComponent = memo(_InnerComponent);

                export default ReconciliationComponent;
					    </code>
            </pre>
            <aside class="notes">
              Now let's create a memoized InnerComponent component that will
              display the name, and also print a message to the console.log when
              it is unmounted.
              <br /><br />
              In the ReconciliationComponent, we will create the items state
              with default values, two functions for pushing new elements into
              the items state array, and two buttons that will call these
              methods.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Reconciliation example</h4>
            <p>reconciliation-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="25-31">
                import React, { useState, useEffect, memo } from "react";

                const ReconciliationComponent = () => {
                  const [items, setItems] = useState([
                    { name: "item 1", key: "item_1" },
                    { name: "item 30", key: "item_30" },
                    { name: "item 70", key: "item_70" },
                    { name: "item 130", key: "item_130" }
                  ]);

                  const handleAddToTop = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  const handleAddToBottom = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  return (
                    &lt;>
                      <ul>
                        {items.map((i) => (
                          &lt;li key={i.key}>
                            &lt;InnerComponent name={i.name} />
                          &lt;/li>
                        ))}
                      </ul>
                      &lt;button onClick={handleAddToTop}>Add to top&lt;/button>
                      &lt;button onClick={handleAddToBottom}>Add to bottom&lt;/button>
                    &lt;/>
                  );
                };

                const _InnerComponent = ({ name }) => {
                  useEffect(() => () => {
                      console.log(`unmount inner component: ${name}`);
                    },
                    [name]
                  );

                  return <p>Inner component {name}</p>;
                };

                const InnerComponent = memo(_InnerComponent);

                export default ReconciliationComponent;
					    </code>
            </pre>
            <aside class="notes">
              Now let's add a mapping to our array, pay attention to the KEY
              attribute we're using.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Reconciliation example</h4>
            <p>index.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="1,3">
                import ReconciliationComponent from "./reconciliation-component";

                export { ReconciliationComponent };
					    </code>
            </pre>
            <aside class="notes">
              Let's the following code to the index.js file
            </aside>
          </section>
          <section class="code-example-slide">
            <h4 class="slide-name">Reconciliation example</h4>
            <p>App.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="23,64-67">
                import "./styles.css";

                import { ClassCounter, FunctionalCounter } from "./components-and-props";
                import { 
                  MountingComponent, 
                  UpdatingComponent, 
                  UnmountingComponent 
                } from "./lifecycle";
                import {
                  UseStateComponent,
                  UseEffectComponent,
                  UseCallbackComponent,
                  UseContextComponent,
                  UseMemoComponent,
                  UseRefComponent,
                  UseCustomHookComponent
                } from "./hooks";
                import { HocComponent } from "./hoc";
                import {
                  ControlledComponent,
                  UncontrolledComponent
                } from "./controlled-uncontrolled";
                import { ReconciliationComponent } from "./reconciliation";                

                const blockStyle = { "border-style": "dotted" };

                export default function App() {
                  return (
                    &lt;div className="App">
                      &lt;div style={blockStyle}>
                        <h1>Functional and class componets</h1>
                        &lt;ClassCounter name={"Class Counter"} />
                        &lt;FunctionalCounter name={"Functional Counter"} />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Lifecycle examples</h1>
                        &lt;MountingComponent name={"FirstName"} />
                        &lt;UpdatingComponent />
                        &lt;UnmountingComponent />
                      &lt;/div>
                      &lt;div style={blockStyle}>
                        <h1>Hooks</h1>
                        &lt;UseStateComponent />
                        &lt;UseEffectComponent />
                        &lt;UseCallbackComponent />
                        &lt;UseContextComponent />
                        &lt;UseMemoComponent />
                        &lt;UseRefComponent />
                        &lt;UseCustomHookComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>HOCs</h1>
                        &lt;HocComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Controlled and uncontrolled components</h1>
                        &lt;ControlledComponent />
                        &lt;UncontrolledComponent />
                      &lt;/div>
                      <br /> <br />
                      &lt;div style={blockStyle}>
                        <h1>Reconciliation</h1>
                        &lt;ReconciliationComponent />
                      &lt;/div>
                    &lt;/div>
                  );
                }              
					    </code>
            </pre>
            <aside class="notes">
              And the last thing we need to do is add our new component to
              App.js.
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">Reconciliation example</h4>
            <div>
              <iframe
                data-src="assets/videos/reconciliation_example.mp4"
              ></iframe>
            </div>
            <aside class="notes">
              As we can see, the display of our array works great, there are no
              unnecessary re-renders.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Reconciliation example</h4>
            <p>reconciliation-component.js</p>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="27-29">
                import React, { useState, useEffect, memo } from "react";

                const ReconciliationComponent = () => {
                  const [items, setItems] = useState([
                    { name: "item 1", key: "item_1" },
                    { name: "item 30", key: "item_30" },
                    { name: "item 70", key: "item_70" },
                    { name: "item 130", key: "item_130" }
                  ]);

                  const handleAddToTop = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  const handleAddToBottom = () =>
                    setItems((prev) => [
                      { name: `Item ${prev.length}`, key: `item_${prev.length}` },
                      ...prev
                    ]);

                  return (
                    &lt;>
                      <ul>
                        {items.map((i) => (
                          &lt;li>
                            &lt;InnerComponent name={i.name} />
                          &lt;/li>
                        ))}
                      </ul>
                      &lt;button onClick={handleAddToTop}>Add to top&lt;/button>
                      &lt;button onClick={handleAddToBottom}>Add to bottom&lt;/button>
                    &lt;/>
                  );
                };

                const _InnerComponent = ({ name }) => {
                  useEffect(() => () => {
                      console.log(`unmount inner component: ${name}`);
                    },
                    [name]
                  );

                  return <p>Inner component {name}</p>;
                };

                const InnerComponent = memo(_InnerComponent);

                export default ReconciliationComponent;
					    </code>
            </pre>
            <aside class="notes">
              Let's try to render our items state without keys
            </aside>
          </section>
          <section class="video-slide">
            <h4 class="slide-name">Reconciliation example</h4>
            <div>
              <iframe
                data-src="assets/videos/reconciliation_example_1.mp4"
              ></iframe>
            </div>
            <aside class="notes">
              As you can see, the situation has changed a lot, additional
              renderers have appeared. Let's conclude that the use of the KEY
              attribute is very important when rendering an array.
            </aside>
          </section>
        </section>

        <!-- FIBER -->
        <section>
          <section class="numbering-and-picture-slide">
            <h4 class="slide-name">Fiber</h4>
            <div>
              <img src="assets/images/fiber.png" alt="fiber" />
              <ol>
                <li>
                  A fiber represents a virtual stack frame with scheduling and
                  prioritizing
                </li>
                <li>
                  <strong>window.requestIdleCallback(callback)</strong
                  ><br />schedules a low priority function to be called during
                  an idle period
                </li>
                <li>
                  <strong>window.requestAnimationFrame(callback); </strong
                  ><br />schedules a high priority function to be called on the
                  next animation frame
                </li>
              </ol>
            </div>
            <aside class="notes">
              React Fiber is a complete rewrite of React's
              <strong>reconciler algorithm</strong>
              to fix some of the longstanding problems in React. The main
              feature is that it implements incremental rendering.
              <br /><br />
              Because Fiber is asynchronous, React can:<br />
              - Pause, resume, and restart rendering work on components as new
              updates come in<br />
              - Reuse previously completed work and even abort it if not
              needed<br />
              - Split work into chunks and prioritize tasks based on importance
              <br /><br />
              By the end of the reconciliation, React knows the result of the
              DOM tree, and a renderer like react-dom or react-native applies
              <strong>the minimal set of changes</strong> necessary to update
              the DOM nodes.This means that when you call ReactDOM.render() or
              setState(), React performs reconciliation. <br /><br />
              What is the React stack reconciler?<br />
              Oh, by the way, why is this called the “stack” reconciler? This
              name is derived from the “stack” data structure, which is a
              last-in, first-out mechanism.<br />
              And, what does stack have anything to do with what we just saw?
              Well, as it turns out, since we are effectively performing
              recursion, it has everything to do with a stack.
              <br /><br />
              The picture shows the main idea, which allows you to
              <strong>redraw UI at least 16 ms</strong>, 16 ms is 60 frames per
              second, which allows you to
              <strong>adjust the feeling</strong> that UI does not slow down.
              <br /><br />
              All tasks are divided into small iterations and executed. Views
              have two callbacks requestIdleCallback and
              requestAnimationFrame.<br />
              requestIdleCallback is called when the browser puts down,
              requestIdleCallback is called for higher priority tasks.
            </aside>
          </section>
          <section class="bullets-slide">
            <h4 class="slide-name">Fiber</h4>
            <ul>
              <li class="fragment">pause work and come back to it later</li>
              <li class="fragment">
                assign priority to different types of work
              </li>
              <li class="fragment">reuse previously completed work</li>
              <li class="fragment">abort work if it's no longer needed</li>
            </ul>
            <aside class="notes">
              The slide shows the features of how a fiber can manage tasks
            </aside>
          </section>
        </section>

        <!-- ADDITIONAL MATERIALS -->
        <section class="video-text-slide">
          <h4 class="slide-name">additional materials</h4>
          <div>
            <div>
              <a
                href="https://www.youtube.com/watch?v=ZCuYPiUIONs"
                target="_blank"
                >A Cartoon Intro to Fiber
              </a>
              <iframe
                src="https://www.youtube.com/embed/ZCuYPiUIONs"
                title="A Cartoon Intro to Fiber
                "
                allowfullscreen
              >
              </iframe>
            </div>
            <div>
              <p>
                <strong>Lin Clark</strong> - work in the emerging technologies
                group at Mozilla.
              </p>
              <p>- Basics about Fiber</p>
            </div>
          </div>
          <aside class="notes">
            In this video you will get more information about the fiber.
          </aside>
        </section>

        <!-- QA -->
        <section class="qa-slide">
          <h4>QA</h4>
        </section>
      </div>
    </div>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/dist/reveal.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/zoom/zoom.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/notes/notes.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/search/search.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/markdown/markdown.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/highlight/highlight.js"></script>
    <script>
      var url = new URL(window.location.href);
      var showNotes = url.searchParams.has("showNotes");

      if (showNotes) {
        var head = document.getElementsByTagName("HEAD")[0];
        var link = document.createElement("link");
        link.rel = "stylesheet";
        link.type = "text/css";
        link.href =
          "https://rolling-scopes-school.github.io/react-native-course/reveal-js/speaker-notes-mobile.css";
        head.appendChild(link);
      }

      Reveal.initialize({
        disableLayout: true,
        controls: true,
        progress: true,
        center: false,
        hash: true,
        autoPlayMedia: true,
        showNotes,
        plugins: [
          RevealZoom,
          RevealNotes,
          RevealSearch,
          RevealMarkdown,
          RevealHighlight,
        ],
      });
    </script>
  </body>
</html>
