<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>react-native-course - Animations module</title>
    <meta
      name="description"
      content="rolling-scopes-school/react-native-course - react module"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../reveal-js/dist/reset.css" />
    <link rel="stylesheet" href="../reveal-js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="../reveal-js/dist/theme/white.css"
      id="theme"
    />
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../reveal-js/plugin/highlight/monokai.css" />
    <link rel="stylesheet" href="../reveal-js/common.css" />
  </head>
  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <!-- 0 slide -->
        <section class="presentation-name-slide">
          <h4>Animations in React Native</h4>

          <aside class="notes">
            Navigation is an important part of mobile development
          </aside>
        </section>
        <section class="agenda-slide">
          <h4 class="slide-name">Agenda</h4>
          <ul>
            <li class="fragment">What is animation?</li>
            <li class="fragment">
              How animation can be done in React Native. A brief overview.
            </li>
            <li class="fragment">Animated API</li>
            <li class="fragment">LayoutAnimation API</li>
            <li class="fragment">Reanimated</li>
            <li class="fragment">Third-party solutions for animations</li>
            <li class="fragment">Conclusion and QA session</li>
          </ul>
          <aside class="notes">
            On this slide you can see today’s agenda.
            <br /><br />
            We will start by talking about what animation is in general and how
            it can be done in React Native.
            <br /><br />
            Here we'll try animating with translation prop directly in JS thread
            and talk about why it is not a good idea. What React Native provides
            in terms of animation (Animated and LayoutAnimations APIs) and what
            are community provided solutions (Reanimated, Lottie, Rive to name a
            few)
            <br /><br />
            Next we'll dive into Animated API by checking code examples and
            discussing its limitations.
            <br /><br />
            LayoutAnimation is our next stop after which we'll take a closer
            look on Reanimated - the most popular and complex third-party
            solution for animation in React Native. What's the reasoning behind
            this library? What are the benefits over Animated and
            LayoutAnimation APIs? Of course there will be a coding section with
            hands on experience here.
            <br /><br />
            Last but not least, we'll try some other third party solutions for
            some really complex animations, like Lottie and more recent Rive
            libraries.
            <br /><br />
            At the end of all that, we'll have plenty time for QA and some
            conclusions. Buckle up and let's get started!
          </aside>
        </section>
        <!-- 1 slide -->
        <section class="picture-slide">
          <h4 class="slide-name">What is animation?</h4>
          <img
            src="assets/images/intro.gif"
            width="400"
            alt="intro animation"
          />
          <aside class="notes">
            As stated in Wikipedia “Animation is a method by which still figures
            are manipulated to appear as moving images.”
          </aside>
        </section>
        <!-- 2 slide -->
        <section class="several-pictures-3-slide">
          <h4 class="slide-name">Animations in mobile applications</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img
                src="assets/images/Animation_ex1.gif"
                height="500"
                alt="Example of animation"
              />
            </div>
            <div class="fragment" data-fragment-index="2">
              <img
                src="assets/images/Animation_ex2.gif"
                height="500"
                alt="Example of animation"
              />
            </div>
            <div class="fragment" data-fragment-index="3">
              <img
                src="assets/images/Animation_ex1.gif"
                height="500"
                alt="Example of animation"
              />
            </div>
          </div>
          <aside class="notes">
            In terms of mobile applications it is basically smoothly taking an
            object from one state to another. Animations allow you to convey
            physically believable motion in your interface. This way we can keep
            application users engaged and it can help to improve user experience
            on the whole.
          </aside>
        </section>
        <section class="several-pictures-2-slide">
          <h4 class="slide-name">How animation can be done in React Native</h4>
          <div>
            <div>
              <ol>
                <li class="fragment" data-fragment-index="1">JavaScript</li>
                <li class="fragment" data-fragment-index="2">
                  React Native APIs:
                  <ul class="fragment" data-fragment-index="3">
                    <li>Animated API</li>
                    <li>LayoutAnimation API</li>
                  </ul>
                </li>
                <li class="fragment" data-fragment-index="4">
                  Third-party solutions:
                  <ul class="fragment" data-fragment-index="5">
                    <li>Reanimated</li>
                    <li>Lottie</li>
                    <li>Rive and others</li>
                  </ul>
                </li>
              </ol>
            </div>
            <div class="fragment" data-fragment-index="6">
              <img
                src="assets/images/threads.png"
                alt="animation threads"
                width="60%"
              />
            </div>
          </div>
          <aside class="notes">
            There are different ways we can animated objects in RN. It can be
            done by simply using object properties changed in time via timeouts.
            Or we can use platform built-in APIs to animate things. Lastly we
            can go for third-party solutions to make things work. On top of that
            we should be aware that animation can run in either JS thread or UI
            thread. Let’s explore the mentioned options and discuss their pros
            and cons.
          </aside>
        </section>
        <!-- JavaScript animation -->
        <section class="stack-preset">
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Animation with plain JavaScript</h4>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers>
                import React, { useState } from 'react';
                import { Button, SafeAreaView, View } from 'react-native';
                import { styles } from './screens.styles';

                export const PlainJsScreen: React.FC = () => {
                  return (
                    &lt;SafeAreaView style={styles.wrapper}&gt;
                      &lt;View style={styles.screenContainer}&gt;
                        &lt;View style={styles.ball} /&gt;
                        &lt;View style={styles.button}&gt;
                          &lt;Button title="Animate!" /&gt;
                        &lt;/View&gt;
                        &lt;View style={styles.button}&gt;
                          &lt;Button title="Reset" /&gt;
                        &lt;/View&gt;
                      &lt;/View&gt;
                    &lt;/SafeAreaView&gt;
                  );
                };
              </code>
            </pre>
            <aside class="notes">
              If you’re familiar with front-end web development, the first idea
              that may come to mind is animate objects using JavaScript. With
              React it can be done easily using state and object properties.
              Let’s animate an object to go up from its initial position using
              the transform property. Here's a basic screen with "Ball" object
              that we're going to animate and two buttons: Animate and Reset. As
              you can see they do nothing yet.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Animation with plain JavaScript</h4>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="6-12">
                import React, { useState } from 'react';
                import { Button, SafeAreaView, View } from 'react-native';
                import { styles } from './screens.styles';

                export const PlainJsScreen: React.FC = () => {
                  const [translation, setTranslation] = useState(0);

                  const onAnimatePress = () => {
                    for (let i = -100; i < 0; i++) {
                      setTimeout(() => setTranslation(i), 10 * -i);
                    }
                  };

                  return (
                    &lt;SafeAreaView style={styles.wrapper}&gt;
                      &lt;View style={styles.screenContainer}&gt;
                        &lt;View
                          style={[
                            styles.ball,
                            {
                              transform: [{ translateY: translation }],
                            },
                          ]}
                        /&gt;
                        &lt;View style={styles.button}&gt;
                          &lt;Button title="Animate!" onPress={onAnimatePress} /&gt;
                        &lt;/View&gt;
                        &lt;View style={styles.button}&gt;
                          &lt;Button title="Reset" onPress={() => setTranslation(0)} /&gt;
                        &lt;/View&gt;
                      &lt;/View&gt;
                    &lt;/SafeAreaView&gt;
                  );
                };
              </code>
            </pre>
            <aside class="notes">
              Next we need to add state for our translation value and animation
              function that will change this value over time.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Animation with plain JavaScript</h4>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="5-10">
                  return (
                    &lt;SafeAreaView style={styles.wrapper}&gt;
                      &lt;View style={styles.screenContainer}&gt;
                        &lt;View
                          style={[
                            styles.ball,
                            {
                              transform: [{ translateY: translation }],
                            },
                          ]}
                        /&gt;
                        &lt;View style={styles.button}&gt;
                          &lt;Button title="Animate!" onPress={onAnimatePress} /&gt;
                        &lt;/View&gt;
                        &lt;View style={styles.button}&gt;
                          &lt;Button title="Reset" onPress={() => setTranslation(0)} /&gt;
                        &lt;/View&gt;
                      &lt;/View&gt;
                    &lt;/SafeAreaView&gt;
                  );
                };
              </code>
            </pre>
            <aside class="notes">
              Next we need to add state for our translation value and animation
              function that will change this value over time.
            </aside>
          </section>
          <section data-auto-animate class="code-example-slide">
            <h4 class="slide-name">Animation with plain JavaScript</h4>
            <pre data-id="code-animation">
              <code class="hljs" data-trim data-line-numbers="12-17">
                  return (
                    &lt;SafeAreaView style={styles.wrapper}&gt;
                      &lt;View style={styles.screenContainer}&gt;
                        &lt;View
                          style={[
                            styles.ball,
                            {
                              transform: [{ translateY: translation }],
                            },
                          ]}
                        /&gt;
                        &lt;View style={styles.button}&gt;
                          &lt;Button title="Animate!" onPress={onAnimatePress} /&gt;
                        &lt;/View&gt;
                        &lt;View style={styles.button}&gt;
                          &lt;Button title="Reset" onPress={() => setTranslation(0)} /&gt;
                        &lt;/View&gt;
                      &lt;/View&gt;
                    &lt;/SafeAreaView&gt;
                  );
                };
              </code>
            </pre>
            <aside class="notes">
              Finally, let's set our function as onPress handler for our
              buttons.
            </aside>
          </section>
          <section class="picture-slide">
            <h4 class="slide-name">Animation with plain JavaScript</h4>
            <img
              src="assets/images/plain_js_animation.gif"
              alt="Animation with plain JS"
            />
            <aside class="notes">
              The result is far from perfection and you can achieve a much
              smoother animation with requestAnimationFrame. Also we can animate
              other ball properties, for instance color and size.
            </aside>
          </section>
          <section class="text-and-picture-slide">
            <h4 class="slide-name">Animation with plain JavaScript</h4>
            <div>
              <img
                src="assets/images/requestAnimationFrame.gif"
                alt="Animation with requestAnimationFrame"
                width="800"
              />
              <ul>
                <li>
                  <a
                    href="https://github.com/DenisKhatsuk/react-native-animations/tree/develop/src/screens/PlainJsScreen"
                  >
                    Code of the requestAnimationFrame example
                  </a>
                </li>
                <li>
                  <a
                    href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"
                  >
                    Documentation on requestAnimationFrame
                  </a>
                </li>
              </ul>
            </div>
            <aside class="notes">
              This approach however has downsides. You can tell the most obvious
              one right away: even simple animations require a lot of coding
              that is pretty complex at first glance. But even more important is
              performance - animation related code will be executed in JS (main)
              thread. This means it will be calculated and executed along with
              your other JS code, which can lead to frames drop, animation being
              stuck and slowing down your app in general.
            </aside>
          </section>
          <section class="text-and-picture-slide">
            <h4 class="slide-name">Animation with plain JavaScript</h4>
            <div>
              <img
                src="assets/images/plain_js_loaded.gif"
                alt="Animation with plain JS and loaded JS thread"
                width="800"
              />
              <ol>
                <li class="fragment">Unnecessary code complexity</li>
                <li class="fragment">
                  Low performance and animation interruptions
                </li>
                <li class="fragment">
                  setState being used.
                  <a
                    href="https://legacy.reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous"
                    >Link to docs</a
                  >
                </li>
              </ol>
            </div>
            <aside class="notes">
              If we load our JS thread, you can see how animation is delayed
              before JS thread is available again. Spot the moment we press the
              button and JS thread frames drop due to a heavy calculation - our
              animation won't start until it's free again. Another big issue is
              that we use state to animate our object position, but state may be
              asynchronous: React may batch multiple setState() calls into a
              single update for performance. So we can’t expect the state will
              be updated on every step as we programmed it and we won’t get the
              smooth animation. So how we can solve all that issues? Let's check 
              what solutions React Native offers.
            </aside>
          </section>
        </section>
        <!-- End: JavaScript animation -->
        <!-- React Native APIs -->
        <section class="several-pictures-2-slide">
          <h4 class="slide-name">React Native APIs</h4>
          <div>
            <div>
              <ol>
                <li class="fragment" data-fragment-index="1">
                  Animated API <a href="https://reactnative.dev/docs/animated">Documentation</a>
              
                </li>
                <li class="fragment" data-fragment-index="2">
                  LayoutAnimation API <a href="https://reactnative.dev/docs/layoutanimation">Documentation</a>
                </li>
              </ol>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img
                src="assets/images/rn_api_choice.png"
                alt="react native animation choices"
              />
            </div>
          </div>
          <aside class="notes">
            In terms of built-in solutions, React Native provides two complementary APIs
            that solve different animation cases. When you need to animate a specific screen 
            element with precise control over all animation stages Animated API is the way to 
            go. On the other hand, situations when we need to animate screen elements between 
            layout changes are much more common. For instance, you'd like to show and hide selected
            input fields depending on the form mode. Or perhaps you'd like to smoothly hide a bottom
            sheet on close button press. LayoutAnimation API is perfect for that. It requires small
            amount of code and provides nice results out of the box.
            Let's dive deeper into the Animated API to see how it works and how we can use it.
          </aside>
        </section>
        <!-- End: React Native APIs -->
        <!-- Animated API animation -->
       <section class="stack-preset">
          <section class="text-slide">
            <h4 class="slide-name">Animated API. Let's start</h4>
            <div>
              <h6 class="fragment" data-fragment-index="1">What:</h6>
              <span class="fragment" data-fragment-index="2"> Animate our component's position</span>
            </div>
            <br>
            <div>
              <h6 class="fragment" data-fragment-index="3">How:</h6>
              <span class="fragment" data-fragment-index="4"> Using 'transform' property animation</span>
            </div>
            <br>
            <div>
              <h6 class="fragment" data-fragment-index="5">What we need:</h6>
              <ol class="fragment" data-fragment-index="6"> 
                <li>A value</li>
                <li>A function that changes our value</li>
                <li>A way to link our component style to the changing value</li>
              </ol>
            </div>
            <aside class="notes">
              Animated library is a built-in solution provided with react native out of the box. 
              It's about connecting inputs and outputs with some configurable transforms in between.
              No worries if it sounds complex now as we'll explore this API step by step.
              Let’s see how it actually  works.
              The first animation we’re going to reproduce is the position animation via ‘transform’ property. 
              In general we need three things:
              A value to animate
              A function that animates our value
              A way to link our component style to the animated value
              Let’s check these items one by one. 
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. Value and animation methods</h4>
            <div>
              <img
                src="assets/images/value_doc.png"
                alt="Animated Value documentation tip"
                width="825"
                class="fragment" data-fragment-index="1"
              />
            </div>
            <pre class="fragment" data-fragment-index="2">
                <code data-trim>
                  import { Animated } from 'react-native';
                </code>
              </pre>
            <pre class="fragment" data-fragment-index="3">
              <code data-trim>
                const translation = useRef(new Animated.Value(0)).current;
              </code>
            </pre>
            <pre class="fragment" data-fragment-index="4">
              <code data-trim data-line-numbers>
                Animated.timing(translation, {
                  toValue: -100,
                  duration: 1000,
                }).start();
              </code>
            </pre>
            <aside class="notes">
              Firstly we need the value that changes gradually over time. Animated has a special Value 
              class for that. To make things work we need to create this class instance in our component. 
              As stated in documentation we shouldn’t modify the animated value directly, instead we can 
              use the useRef hook to create the Value class instance once on component render.
              Now when we have an animated value, we need a way to animate it. Animated provides a set of 
              methods we can use and timing() fits our needs perfectly here. It animates a value in time.
              Timing method expects two parameters: value to animate and the config object. Via configuration 
              object we can set to what value the animation will go and animation duration. It has other props 
              that we’ll discuss later.
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. Animated components</h4>
            <pre class="fragment" data-fragment-index="1">
                <code data-trim>
                  &lt;Animated.View
                    style={[
                      styles.ball,
                      {
                        transform: [{ translateY: translation }],
                      },
                    ]}
                    /&gt;
                  &lt;/Animated.View&gt;
                </code>
              </pre>
            <h6 class="fragment" data-fragment-index="2">
              Animated components:
            </h6>
            <div class="fragment" data-fragment-index="3">
              <ul>
                <li>View</li>
                <li>Text</li>
                <li>ScrollView</li>
                <li>FlatList</li>
                <li>SectionList</li>
                <li>Image</li>
              </ul>
            </div>
            <aside class="notes">
              We’re almost done. Regular RN components won’t work with the animated value in their styles, so 
              Animated has its own versions of some components. In our case we need Animated.View. Inline 
              styling is a no-no, so it's here only for explanation purposes.
              Other possible Animated components are FlatList, Image, ScrollView, SectionList and Text. 
            </aside>
          </section>
          <section class="text-slide">
            <h4 class="slide-name">Animated API. timing method</h4>
            <h6>
              timing() method options:
            </h6>
            <div>
              <ul>
                <li class="fragment" data-fragment-index="1">duration</li>
                <li class="fragment" data-fragment-index="2">easing</li>
                <li class="fragment" data-fragment-index="3">delay</li>
                <li class="fragment" data-fragment-index="4">isInteraction</li>
                <li class="fragment" data-fragment-index="5">useNativeDriver</li>
              </ul>
            </div>
            <aside class="notes">
              Now everything works and we already have much smoother animation. So it’s time to check what other 
              options are available for our timing method. Till now we used toValue and duration. As per 
              documentation, the full list is:
                - duration: Length of animation (milliseconds). Default 500. 
                - easing: Easing function to define curve. Default is Easing.inOut(Easing.ease). 
                - delay: Start the animation after delay (milliseconds). Default 0. 
                - isInteraction: Whether or not this animation creates an "interaction handle" on the 
                  InteractionManager. Default true. 
                - useNativeDriver: Uses the native driver when true. Default false.
              I’d like to discuss two new options from this list: easing and useNativeDriver.
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. Easing</h4>
            <div>
              <p class="fragment" data-fragment-index="1">
                Easing allows you to specify the function that defines how animated parameter will 
                change over time.
              </p>
              <p class="fragment" data-fragment-index="2">
                <a href="https://easings.net/">Easing Functions</a>
              </p>
            </div>
            <pre class="fragment" data-fragment-index="3">
              <code data-trim>
                import { Animated, Easing } from 'react-native';
              </code>
            </pre>
            <pre class="fragment" data-fragment-index="4">
              <code data-trim data-line-numbers>
                Animated.timing(translation, {
                  toValue: -100,
                  duration: 1000,
                  easing: Easing.bounce,
                }).start();
              </code>
            </pre>
            <div>
              <p class="fragment" data-fragment-index="5">
                <a href="https://reactnative.dev/docs/easing#methods">Easing Methods</a>
              </p>
            </div>
            <pre class="fragment" data-fragment-index="6">
              <code data-trim data-line-numbers>
                Animated.timing(translation, {
                  toValue: -100,
                  duration: 1000,
                  easing: Easing.out(Easing.bounce),
                }).start();
              </code>
            </pre>
            <aside class="notes">
              Easing allows you to specify the function that defines how animated parameter will change 
              over time. This can help to achieve more natural looking motion - in real life objects almost 
              never move at the linear speed. The default easing in timing method is ‘ease in out’ - when 
              animation starts a bit slower, then runs at a regular speed and slows down before the end. 
              Feel free to check other easing function examples at https://easings.net/.
              At this point you may wonder how to implement other easing functions to apply them in your 
              animation. RN provides Easing module for that.
              Available methods can be found in RN docs: https://reactnative.dev/docs/easing#methods. 
              Some of them require additional parameters.
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. useNativeDriver</h4>
            <div>
              <p class="fragment" data-fragment-index="1">
                useNativeDriver when set to 'true' sends all the animation data processing to the UI thread (native side).
              </p>
            </div>
            <pre class="fragment" data-fragment-index="2">
              <code data-trim data-line-numbers>
                Animated.timing(translation, {
                  toValue: -200,
                  duration: 1500,
                  useNativeDriver: true,
                }).start();
              </code>
            </pre>
            <h6 class="fragment" data-fragment-index="3">
              <span style="text-transform: none;">useNativeDriver</span> features to be aware of:
            </h6>
            <div class="fragment" data-fragment-index="4">
              <ul>
                <li>Animated values are only compatible with one driver.</li>
                <li>Not all Animated features are supported with native driver.</li>
              </ul>
            </div>
            <div>
              <p class="fragment" data-fragment-index="5">
                If you use native driver while animating the value, every animation on this value further 
                should use the native driver too.
              </p>
              <p class="fragment" data-fragment-index="6">
                You can only animate non-layout properties (transform, opacity) - position and flexbox 
                properties won’t work.
              </p>
            </div>
            <aside class="notes">
              Now it’s time to discuss the useNativeDriver prop. By setting this prop to ‘true’ we can 
              send all the animation data to native side, so our animation runs in the UI thread and the 
              JS thread can’t affect the animation anymore.
              When using the native driver we should be aware of its two features:
              - Animated values are only compatible with one driver. 
                This means if you use native driver 
                while animating the value, every animation on this value further should use the native driver 
                too. So you can’t run one animation on ‘translation’ value from our example using the native 
                driver and then fire another one that doesn’t use it.

              - Not all Animated features are supported with native driver. 
                You can only animate non-layout properties (transform, opacity) - position and flexbox properties 
                won’t work.
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. Composition</h4>
            <h6 class="fragment" data-fragment-index="1">
              Composition functions:
            </h6>
            <div class="fragment" data-fragment-index="2">
              <ul>
                <li>Animated.delay(). Starts an animation after a given delay.</li>
                <li>Animated.parallel(). Starts a number of animations at the same time.</li>
                <li>
                  Animated.sequence(). Starts the animations in order, waiting for each to 
                  complete before starting the next. 
                </li>
                <li>Animated.stagger(). Starts animations in order and in parallel, but with successive delays.</li>
              </ul>
            </div>
            <aside class="notes">
              Okay, now when we get this sorted, let’s discuss animation composition. Animated provides four 
              helpers for that:
              - Animated.delay() starts an animation after a given delay.
              - Animated.parallel() starts a number of animations at the same time.
              - Animated.sequence() starts the animations in order, waiting for each to complete before 
                starting the next. 
              - Animated.stagger() starts animations in order and in parallel, but with successive delays.
              Animated.delay is pretty straight forward, so let's skip it for now as we're going to see it in use
              later and start with parallel method.
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. Composition. Parallel</h4>
            <div>
              <p class="fragment" data-fragment-index="1">
                To launch animations in parallel we simply need to wrap them with Animated.parallel([]).
              </p>
            </div>
            <pre class="fragment" data-fragment-index="2">
              <code data-trim data-line-numbers>
                Animated.parallel([
                  Animated.timing(nativeTranslation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: true,
                  }),
                  Animated.timing(translation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: false,
                  }),
                  Animated.timing(size, {
                    toValue: 50,
                    duration: 1500,
                    useNativeDriver: false,
                  }),
                ]).start();
              </code>
            </pre>
            <div>
              <p class="fragment" data-fragment-index="3">
                If one animation is stopped or interrupted, all other animations in parallel are also stopped:
              </p>
            </div>
            <pre class="fragment" data-fragment-index="4">
              <code data-trim data-line-numbers>
                const onStopPress = () => {
                  Animated.timing(translation, {
                    toValue: -100,
                    useNativeDriver: false,
                  }).stop();
                };
              </code>
            </pre>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. Composition. Sequence</h4>
            <div>
              <p class="fragment" data-fragment-index="1">
                Sequence launches the provided animations one after another:
              </p>
            </div>
            <pre class="fragment" data-fragment-index="2">
              <code data-trim data-line-numbers>
                Animated.sequence([
                  Animated.timing(nativeTranslation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: true,
                  }),
                  Animated.timing(translation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: false,
                  }),
                  Animated.timing(size, {
                    toValue: 50,
                    duration: 1500,
                    useNativeDriver: false,
                  }),
                ]).start();
              </code>
            </pre>
            <div>
              <p class="fragment" data-fragment-index="3">
                If the current running animation is stopped, no following animations will be started.
              </p>
            </div>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. Composition. Stagger</h4>
            <div>
              <p class="fragment" data-fragment-index="1">
                Stagger is very similar, but it allows you to additionally specify the delay between animations:
              </p>
            </div>
            <pre class="fragment" data-fragment-index="2">
              <code data-trim data-line-numbers>
                Animated.stagger(2000, [
                  Animated.timing(nativeTranslation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: true,
                  }),
                  Animated.timing(translation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: false,
                  }),
                  Animated.timing(size, {
                    toValue: 50,
                    duration: 1500,
                    useNativeDriver: false,
                  }),
                ]).start();
              </code>
            </pre>
            <div>
              <p class="fragment" data-fragment-index="3">
                Array of animations may run in parallel (overlap) if you specify duration values that are 
                longer than delay between animations.
              </p>
            </div>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. Composition. Delay</h4>
            <div>
              <p class="fragment" data-fragment-index="1">
                Animated.delay() is meant to be used in Stagger or Sequence to put delays between animations:
              </p>
            </div>
            <pre class="fragment" data-fragment-index="2">
              <code data-trim data-line-numbers>
                Animated.sequence([
                  Animated.timing(nativeTranslation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: true,
                  }),
                  Animated.delay(2000),
                  Animated.timing(translation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: false,
                  }),
                ]).start();
              </code>
            </pre>
            <div>
              <p class="fragment" data-fragment-index="3">
                You can pass delay to animation config as an option with the same result:
              </p>
            </div>
            <pre class="fragment" data-fragment-index="4">
              <code data-trim data-line-numbers>
                Animated.sequence([
                  Animated.timing(nativeTranslation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: true,
                  }),
                  Animated.timing(translation, {
                    toValue: -200,
                    delay: 2000,
                    duration: 1500,
                    useNativeDriver: false,
                  }),
                ]).start();
              </code>
            </pre>
            <aside class="notes">
              While you can use both options to set the delay, in case of sequence/stagger explicit
              Animated.delay() may be more visible and easy to read on quick sight. Something to consider,
              but the preferred way is a matter of taste at the end of the day.
            </aside>
          </section>
          <section class="text-and-conding-slide">
            <h4 class="slide-name">Animated API. Composition. Combination</h4>
            <div>
              <p class="fragment" data-fragment-index="1">
                Not only Animated.delay() can be used in combination with other methods:
              </p>
            </div>
            <pre class="fragment" data-fragment-index="2">
              <code data-trim data-line-numbers>
                Animated.sequence([
                  Animated.timing(nativeTranslation, {
                    toValue: -200,
                    duration: 1500,
                    useNativeDriver: true,
                  }),
                  Animated.parallel([
                    Animated.timing(translation, {
                      toValue: -200,
                      duration: 1500,
                      useNativeDriver: false,
                    }),
                    Animated.timing(size, {
                      toValue: 50,
                      duration: 1500,
                      useNativeDriver: false,
                    }),
                  ]),
                ]).start();
              </code>
            </pre>
          </section>
          <section class="video-text-slide">
            <h4 class="slide-name">Animated API. Spring</h4>
            <div>
              <p class="fragment" data-fragment-index="1">
                Spring() is a method that animates a value according to a spring based model.
              </p>
              <div class="fragment" data-fragment-index="2">
                <video width="640" height="480" controls muted>
                  <source src="assets/videos/Oscillatory_motion_acceleration.ogv" type="video/ogg">
                  <a href="https://en.wikipedia.org/wiki/File:Oscillatory_motion_acceleration.ogv">Spring demo on Wikipedia</a>
                </video>
              </div>
            </div>
            <aside class="notes">
              Till now we’ve used the timing() method for all our animations. Another commonly used method is spring(). 
              This method animates a value according to a spring based model.
            </aside>
          </section>
          <section class="video-text-slide">
            <h4 class="slide-name">Animated API. Spring</h4>
            <div>
              <div>
                <p class="fragment" data-fragment-index="1">
                  In case of spring we don’t specify the animation duration directly. 
                  Instead we have a config object where we can set speed::
                </p>
                <pre class="fragment" data-fragment-index="2">
                  <code data-trim data-line-numbers>
                    Animated.spring(nativeTranslation, {
                      toValue: -100,
                      useNativeDriver: true,
                      speed: 12,
                      bounciness: 30,
                    }).start();
                  </code>
                </pre>
                <p class="fragment" data-fragment-index="4">
                  With spring() use either speed/bounciness or friction/tension pair of settings to control your animation.
                </p>
                <p class="fragment" data-fragment-index="5">
                  <a href="https://reactnative.dev/docs/animated#spring">Docs for spring configuration</a>
                </p>
              </div>
              <div class="fragment" data-fragment-index="3">
                <video width="640" muted loop>
                  <source src="assets/videos/SpringAnimation.mov">
                  Spring animation demo video
                </video>
              </div>
            </div>
            <aside class="notes">
              Please notice that you can use either speed/bounciness or friction/tension settings to control your animation. 
              If you try to specify speed and tension at the same time, you’ll get an error. Other available options are 
              listed in RN docs: https://reactnative.dev/docs/animated#spring
              We’ve just successfully animated the  numeric transform value. But what if I’d like to animate color? 
              That’s where interpolation enters the scene.
            </aside>
          </section>
        </section>
        <!-- End: Animated API animation -->
        </section>
      </div>
    </div>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/dist/reveal.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/zoom/zoom.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/notes/notes.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/search/search.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/markdown/markdown.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/highlight/highlight.js"></script>
    <script>
      var url = new URL(window.location.href);
      var showNotes = url.searchParams.has("showNotes");

      if (showNotes) {
        var head = document.getElementsByTagName("HEAD")[0];
        var link = document.createElement("link");
        link.rel = "stylesheet";
        link.type = "text/css";
        link.href =
          "https://rolling-scopes-school.github.io/react-native-course/reveal-js/speaker-notes-mobile.css";
        head.appendChild(link);
      }

      Reveal.initialize({
        disableLayout: true,
        controls: true,
        progress: true,
        center: false,
        hash: true,
        autoPlayMedia: true,
        showNotes,
        plugins: [
          RevealZoom,
          RevealNotes,
          RevealSearch,
          RevealMarkdown,
          RevealHighlight,
        ],
      });
    </script>
  </body>
</html>
