<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>rolling-scopes-school/react-native-course - React Native Fundamentals module</title>
    <meta
      name="description"
      content="rolling-scopes-school/react-native-course - name module"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/dist/reset.css"
    />
    <link
      rel="stylesheet"
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/dist/reveal.css"
    />
    <link
      rel="stylesheet"
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/dist/theme/white.css"
      id="theme"
    />
    <!-- Theme used for syntax highlighting of code -->
    <link
      rel="stylesheet"
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/highlight/monokai.css"
    />
    <!-- 
      USE THIS IN YOUR PRESENTATION
      href="https://rolling-scopes-school.github.io/react-native-course/reveal-js/common.css" 
    -->
    <link rel="stylesheet" href="../reveal-js/common.css" />
    <style class="jsStyle"></style>
  </head>
  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section class="presentation-name-slide">
          <h4>React Native Fundamentals</h4>
        </section>

        <section class="agenda-slide">
          <h4 class="slide-name">AGENDA</h4>
          <ul>
            <li class="fragment">Introduction</li>
            <li class="fragment">Environment setup</li>
            <li class="fragment">Project structure overview</li>
            <li class="fragment">Components</li>
            <li class="fragment">Styles</li>
            <li class="fragment">Architecture</li>
            <li class="fragment">Code Quality Tools</li>
          </ul>
        </section>
        
        <section class="topic-name-slide">
          <h4>Introduction</h4>
        </section>

        <section class="picture-slide">
          <h4 class="slide-name">What is React Native</h4>
          <img src="assets/images/intro.png" alt="simple" />
          <aside class="notes">
            React Native is a popular <strong>JavaScript-based mobile app framework</strong> that allows you to build natively-rendered mobile apps for iOS and Android. It also can be used to develop applications for Web. The framework lets you create an application for various platforms by using the same codebase. React Native also allows you to implement code in OS-native languages.<br>
          </aside>  
        </section>

        <section class="picture-slide">
          <h4 class="slide-name">iOS and Android</h4>
          <img src="assets/images/ios-and-android.png" alt="simple" />
          <aside class="notes">
            Since React Native is a JavaScript framework used for developing a real, <strong>native</strong> mobile application for <strong>iOS and Android</strong>, let’s take a closer look at these two platforms.
          </aside>
        </section>

        <section class="bullets-and-picture-slide">
          <h4 class="slide-name">Android</h4>
          <div>
            <img src="assets/images/android_set.png" alt="simple" />
            <ul>
              <li>Android Studio</li>
              <li>Android apps can be written using Kotlin and Java languages</li>
              <li>Android Emulator</li>
            </ul>
          </div>
          <aside class="notes">
            Google’s Android operating system is a mobile-based open-source platform. Nowadays, most smartphones, tablets, televisions, and other devices run on android. Android is open source and hence the source code is available for all developers. In totality it is called the Android <strong>SDK</strong>(also known as the software development kit). <strong>SDK</strong> is a set of software tools and programs used by developers to create applications for specific platforms.<br>Android apps can be written using <strong>Kotlin, Java</strong>, and <strong>C++</strong> languages. The Android SDK tools compile your code along with any data and resource files into an <strong>APK</strong> or an <strong>Android App Bundle.</strong><br>An <strong>Android package</strong>, which is an archive file with an <strong>.apk</strong> suffix, contains the contents of an Android app that are required at runtime and it is the file that Android-powered devices use to install the app.<br>An <strong>Android App Bundle</strong>, which is an archive file with an <strong>.aab</strong> suffix, contains the contents of an Android app project including some additional metadata that is not required at runtime.<br>The easiest way to get started with developing Android applications is to download the Android Studio application suite. <strong>Android Studio is the official IDE for Android</strong>. It is a software suite that was built by Google and has all the tools built in to build a high-quality Android app. You can run your app on an actual physical device or emulator. The Android <strong>Emulator</strong> simulates Android devices on your computer so that you can test your application on a variety of devices and Android API levels without needing to have each physical device.<br>
          </aside>
        </section>

        <section class="bullets-and-picture-slide">
          <h4 class="slide-name">iOS</h4>
          <div>
            <img src="assets/images/ios_set.png" alt="simple" />
            <ul>
              <li>Xcode</li>
              <li>Objective-C, Swift languages</li>
              <li>Simulator</li>
            </ul>
          </div>
          <aside class="notes">
            iOS is the mobile operating system that runs on Apple`s mobile devices, most notably the iPhone and the iPad.<br>Native iOS applications can be written in <strong>Objective-C</strong> or <strong>Swift</strong>. Swift is a relatively newer language, introduced only in 2014, while Objective-C is more of an old school programming language.<br>Just like an APK (Android Application Package) file can be installed on Android devices, an IPA file can be used for <strong>testing iOS applications.</strong><br>An <strong>.ipa</strong> file is an iOS and iPadOS application archive file which stores an iOS/iPadOS app. Each .ipa file includes a binary and can only be installed on an iOS/iPadOS or ARM-based macOS device.<br>To develop iOS apps you should use Xcode. <strong>Xcode</strong> is the IDE (Integrated Development Environment) that Apple creates and uses for iOS and OS X development. <br>You can testing your app on an actual physical iOS device or the <strong>Simulator</strong>.<br>
          </aside>
        </section>

        <section class="several-pictures-3-slide-with-description">
          <h4 class="slide-name">Types of apps</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/native-type.png" alt="simple" />
              <p>Native</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/hybrid-type.png" alt="simple" />
              <p>Hybrid</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/web-type.png" alt="simple" />
              <p>Web</p>
            </div>
          </div>
          <aside class="notes">
            Now, for better understanding place of react native in mobile development let’s see <strong>what are the different types of mobile apps.</strong><br>There are three basic types of mobile apps:<br>* <strong>Native apps</strong> are designed to be “native” to one platform, whether it’s Apple iOS, Google’s Android, or Windows Phone. The native platform can be advantageous because it tends to optimize the user experience. Because it was developed specifically for the platform, it can operate more quickly and intuitively.<br>* <strong>Web apps</strong> are responsive versions of websites that can work on any mobile device or OS because they’re delivered using a mobile browser.<br>* <strong>Hybrid apps</strong> are combinations of both native and web apps, but wrapped within a native app, giving it the ability to have its own icon or be downloaded from an app store. So, these apps can be installed on devices just like native apps, but they run through web browsers. All hybrid apps are developed through the HTML5 programming language. Though hybrid apps are not as fast or reliable as native apps.<br>
          </aside>
        </section>

        <section class="several-pictures-2-slide-with-description">
          <h4 class="slide-name">Hybrid or Cross-platform?</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/cordova.png" alt="simple" />
              <p>Cordova</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/rn_crosspl.png" alt="simple" />
              <p>React Native</p>
            </div>
          </div>
          <aside class="notes">
            There are a lot of different types if mobile apps, but where does React Native fit in? React Native was built with the goal of learn once, write anywhere. React Native is a <strong>cross-platform</strong> technology that allows building mobile applications using only JavaScript. While it’s technically a hybrid platform in that it can be written in one language, it has several “native” features. However, it actually compiles into <strong>native views</strong>. It is a true <strong>native app</strong> with views that are native to each platform. This solves one of the biggest user experience problems with traditional web hybrid platforms like Ionic or Cordova, that <strong>are rendered using Web Views</strong>. This web app can use the native wrapper to access features on the device, like the camera roll.<br>- The advantage is that developers can write apps that run on multiple platforms.<br>- The disadvantage, though, is that it’s hard to make these apps look and feel like real native applications.<br>
          </aside>
        </section>

        <section class="picture-slide">
          <h4 class="slide-name">Selection of CLI</h4>
          <img src="assets/images/rn_and_expo.png" alt="simple" />
          <aside class="notes">
            A Command Line Interface (CLI) is a visual interface where programmers can run commands to develop apps. There are two popular ways to create a React Native app — you can use the Expo CLI or you can use the React Native <strong>CLI</strong>.
          </aside>  
        </section>

        <section class="bullets-and-picture-slide">
          <h4 class="slide-name">Expo CLI</h4>
          <div>
            <img src="assets/images/expo.png" alt="simple" />
            <div class="pros-cons-section">
              <p class="big">
                Pros:
              </p>
              <ul>
                <li>Easy set up</li>
                <li>Don't need an emulator or a Mac</li>
                <li>You can share your app live throughout development</li>
                <li>Own set of basic libraries</li>
              </ul>
              <p class="big">
                Cons:
              </p>
              <ul>
                <li>Can’t add native modules</li>
                <li>Not All iOS And Android APIs Are Available</li>
                <li>Can’t use native code libraries</li>
                <li>Size of app is large</li>
                <li>Queue  for building</li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            Expo is a toolchain based on React Native that will help you set up applications quickly.<br>You do not need an emulator or a Mac to run React Native apps with Expo. You can simply download the <strong>Expo client app</strong> for <strong>Andriod</strong> and <strong>IOS</strong> and then run the project on your phone.<br>Once you run your app using the expo start or npm start command, the browser-based DevTools UI would open up with a QR code. Thereby, you can share this QR code and you can <strong>share your app live</strong> throughout development.<br>Expo offers you the Expo SDK, which you can use for some local mobile functions, like MapView, ImagePicker, etc. <br>However, if you use Expo CLI to develop applications, you can only use the Expo ecosystem. <br>
            There are some limitations with Expo as you <strong>can’t add native modules</strong>. Unlike in React React Native CLI, you <strong>can’t use native code libraries</strong> that use Objective-C/Java. The executable size is large which can hurt the overall downloads. Besides this, building in Expo requires you to wait for your turn in queue and there are times when you’re very late to the queue and the build might take up to 3-4 hours to complete.<br>
          </aside>
        </section>

        <section class="bullets-and-picture-slide">
          <h4 class="slide-name">React Native CLI</h4>
          <div>
            <img src="assets/images/rn.png" alt="simple" />
            <div class="pros-cons-section">
              <p class="big">
                Pros:
              </p>
              <ul>
                <li>Native modules</li>
                <li>Third-party plugin support</li>
                <li>Build without waiting in queue</li>
              </ul>
              <p class="big">
                Cons:
              </p>
              <ul>
                <li>Initiating a project can be time-consuming</li>
                <li>Andriod Studio and XCode is needed</li>
                <li>Share is a bit harder</li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            <strong>React Native CLI</strong> is a built-in feature that helps you take control over the management of the project locally. The strongest feature is that with React Native CLI, you can <strong>add native modules written in Java/Objective-C.</strong> So, If you want to write you own native module and integrate it with your React Native application then you can do it easily with React Native CLI.<br>The good thing about React-Native CLI is that it gives you complete freedom to implement any third-party plugins you want with the liberty to customize any implementation.<br>In React Native CLI, the building process happens entirely on your system. This means you don`t have to wait in queue. You just build your application whenever you want.<br>
            Initiating a project with React Native CLI can be <strong>time-consuming. </strong><br>This is mainly because of the <strong>complicated device configurations</strong>. You need to set the environment variables and ensure you have the right required SDKs for your application to function.<br>To build cross-platform mobile apps using the React Native CLI, you need both Andriod and IOS emulators. This means you need to have <strong>Andriod Studio and XCode</strong> to run your projects, which are available exclusively on the <strong>Mac.</strong> Sharing an app can be troublesome. This is because you need to build a <strong>whole APK or IPA file.</strong> <br>
          </aside>
        </section>

        <section class="table-slide">
          <h4 class="slide-name">React-native vs. Expo</h4>
          <table class="fragment" data-fragment-index="2">
            <thead>
              <tr>
                <th></th>
                <th>React Native</th>
                <th>Expo</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Native modules</td>
                <td>+</td>
                <td>-</td>
              </tr>
              <tr>
                <td>Hello World app size</td>
                <td>~5 mb</td>
                <td>~25 mb</td>
              </tr>
              <tr>
                <td>Need Android Studio and XCode</td>
                <td>+</td>
                <td>-</td>
              </tr>
              <tr>
                <td>App share</td>
                <td>Harder (.apk or .ipa)</td>
                <td>Easy (QR-code)</td>
              </tr>
            </tbody>
          </table>
          <aside class="notes">
            Well, as you can see, the selection of the CLI is dependent on the requirements and feature set that is to be implemented.
Given a comparison of the cons and props of both frameworks, I would suggest screening through the requirements and choosing which one suits your application most.
          </aside>
        </section>

        <section class="picture-slide">
          <h4 class="slide-name">Alternatives</h4>
          <img src="assets/images/alternatives.png" alt="simple" />
          <aside class="notes">
            React Native is not the only one technology, that allow you to build mobile apps for both iOS and Android. You can also do it with Flutter and Ionic. 
          </aside>
        </section>

        <section class="bullets-and-picture-slide">
          <h4 class="slide-name">Flutter</h4>
          <div>
            <img src="assets/images/flutter_big.png" alt="simple" />
            <div class="pros-cons-section">
              <p class="big">
                Pros:
              </p>
              <ul>
                <li>UI building components, Widgets</li>
                <li>Dart support</li>
                <li>Perfomance</li>
              </ul>
              <p class="big">
                Cons:
              </p>
              <ul>
                <li>Scarce ecosystem</li>
                <li>Design features for iOS may not be up to date</li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            Powered by Google, Flutter designs native-type applications on Android and iOS. Flutter was launched in 2017 and consists of widgets as its building blocks. It uses Dart, which is developed by Google as well. Dart is based on C/C++.<br><strong>Flutter advantages.</strong> Flutter ships with a <strong>comprehensive suite</strong> of built-in widgets. With these widgets, you can quickly create nice-looking UIs without doing too much manual styling. UI building components, Widgets, are rendered only when necessary that resembles a declarative approach applied in React. <strong>Flutter</strong> use Dart to develop high-quality applications for Android, iOS and the web. Dart supports both AOT(Ahead-of-time) and JIT(Just-in-time) compilation that improves app startup times and overall performance.<br><strong>Disadvantages of Flutter.</strong> \tScarce ecosystem. Despite impressive support by Google and numerous helpful libraries for Flutter, the framework still lacks a rich set of ready-to-use solutions to cover most functionalities. Also, Flutter allows you to enjoy building Android apps fast and efficient. However, design features of some widgets for iOS may not be up to date, which is an issue from a time-efficiency perspective.<br>
          </aside>
        </section>

        <section class="bullets-and-picture-slide">
          <h4 class="slide-name">Ionic</h4>
          <div>
            <img src="assets/images/ionic_big.png" alt="simple" />
            <div class="pros-cons-section">
              <p class="big">
                Pros:
              </p>
              <ul>
                <li>Short development cycle</li>
                <li>Easy-to-learn</li>
              </ul>
              <p class="big">
                Cons:
              </p>
              <ul>
                <li>Lower performance</li>
                <li>App will look the same regardless of platform</li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            An open source SDK launched in 2013. It uses multiple technologies (including HTML5, CSS, and JS) to develop and run applications and access the <strong>Cordova wrapper</strong> to use native platform controllers. Ionic is a successor of Cordova, but with improved documentation and powerful command line interface. Another technology that influenced the framework is Angular. Hence, if you have a background of the mentioned tools, you’ll have no trouble with creating apps using Ionic.<br><strong>Advantages of Ionic.</strong><br>With Ionic, you do not have to spend much time working with native languages or other platform-specific issues. There is a plethora of native-styled UI components. As a result, the development cycle is shorter. The framework is easy-to-learn, and the bulk of engineers are familiar with the technologies under the Ionic’s hood. Fast prototyping with Ionic is possible due to the preset templates not to mention a variety of third-party starter kits.<br><strong>Disadvantages of Ionic.</strong><br>Performance is the price you have to pay for the advantages of hybrid app development. Performance issues are possible in case of numerous callbacks sent to the native code. Also, native UI look is what you should forget about when using Ionic. Your app will look the same regardless of the platform/device it runs on.<br>
          </aside>
        </section>

        <section class="several-icons-3-slide-with-description">
          <h4 class="slide-name">Summary</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/rn_logo.png" alt="simple" />
              <p>React Native</p>
              <ul>
                <li>JavaScript, platform-specific language</li>
                <li>Close to native performance</li>
                <li>Native components</li>
              </ul>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/ionic.png" alt="simple" />
              <p>Ionic</p>
              <ul>
                <li>HTML5, CSS, and JS</li>
                <li>Lower performance</li>
                <li>Web UI components</li>
              </ul>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/flutter.png" alt="simple" />
              <p>Flutter</p>
              <ul>
                <li>Dart</li>
                <li>Better performance</li>
                <li>Proprietary widgets</li>
              </ul>
            </div>
          </div>
        </section>

        <section class="topic-name-slide">
          <h4>Environment setup</h4>
        </section>

        <section class="numbering-and-picture-slide">
          <h4 class="slide-name">Environment setup</h4>
          <div>
            <img src="assets/images/setup_logos.png" alt="simple" />
            <ol>
              <li>Node</li>
              <li>Watchman (optional)</li>
              <li>React Native command line interface</li>
              <li>JDK (android)</li>
              <li>Android Studio (android)</li>
              <li>Xcode (iOS)</li>
              <li>CocoaPods (iOS)</li>
            </ol>
          </div>
          <aside class="notes">
            Let’s talk about how can you install and build your React Native app.<br>So, what do we need? Let’s take a closer look on dependencies.<br>You will need to install Node, Watchman, the React Native command line interface, a JDK, and Android Studio, Xcode (iOS), CocoaPods (iOS). (And some IDE that supports js, for example Visual Studio Code).<br>The first three are common for both platform (android and iOS).<br><strong>NodeJS is a Javascript</strong> cross-platform <strong>runtime environment</strong>. React Native uses Node. js, <strong>to build your JavaScript code.</strong><br><strong>Watchman</strong> is a tool by Facebook for watching changes in the filesystem. It is highly recommended you install it for better performance. React Native uses watchman <strong>to detect when you`ve made code changes and then automatically build and push the update to your device without you needing to manually refresh it</strong>.<br>TODO React Native command line interface<br>Now, let’s see what we need for android<br><strong>JDK</strong> (Java Development Kit) is a cross-platformed software development environment. <strong>The JDK provides tools, such as the Java compiler, used by IDEs and SDKs for developing Java programs.</strong><br><strong>Android Studio is the official IDE for Android.</strong><br>And, when we talk about what we need for iOS, it’s <br><strong>Xcode</strong> (iOS)  is the IDE for iOS<br>And <strong>CocoaPods</strong> (iOS) witch is a dependency manager for Swift and Objective-C Cocoa projects. <strong>React Native uses Cocoapods to add iOS dependencies when you add new modules to your application.</strong><br>
          </aside>
        </section>

        <section class="text-and-frame-slide">
          <h4 class="slide-name">Creating a new application</h4>
          <div>
            <p>To create a new project just run:</p>
            <div class="frame">
              <code class="js" data-trim data-line-numbers>
                npx react-native init yourProject
              </code>
            </div>

            <p>[Optional]</p>
            <p>Using a specific version:</p>
            <div class="frame">
              <code class="js" data-trim data-line-numbers>
                npx react-native init yourProject --version X.XX.X
              </code>
            </div>

            <p>Using a specific template:</p>
            <div class="frame">
              <code class="js" data-trim data-line-numbers>
                npx react-native init yourTSProject --template react-native-template-typescript
              </code>
            </div>
          </div>

          <aside class="notes"></aside>
        </section>

        <section class="topic-name-slide">
          <h4>Project structure overview</h4>
        </section>

        <section class="bullets-and-picture-slide">
          <h4 class="slide-name">Default structure</h4>
          <div>
            <img src="assets/images/default_structure.png" alt="simple" />
            <ul>
              <li>App.js: main component.</li>
              <li>index.js: entry point of your application.</li>
              <li>android and ios: native code or project configuration.</li>
              <li>metro.config.js: metro configuration file.</li>
              <li>package.json: project metadata, dependancies, and scripts.</li>
            </ul>
          </div>
          <aside class="notes"></aside>
        </section>

        <section class="text-and-frame-slide">
          <h4 class="slide-name">Scripts</h4>
          <div>
            <p>Runs your android app:</p>
            <div class="frame">
              <code class="js" data-trim data-line-numbers>
                "android": "react-native run-android” 
              </code>
            </div>

            <p>Runs your ios app:</p>
            <div class="frame">
              <code class="js" data-trim data-line-numbers>
                "ios": "react-native run-ios”
              </code>
            </div>

            <p>Starts Metro Bundler:</p>
            <div class="frame">
              <code class="js" data-trim data-line-numbers>
                "start": "react-native start”
              </code>
            </div>

            <p>Example:</p>
            <div class="frame">
              <code class="js" data-trim data-line-numbers>
                "install:full": "rm -rf node_modules && npm install && rm -rf /tmp/metro-bundler-cache-* && cd ./ios && pod install"
              </code>
            </div>

          <aside class="notes">
            •The <strong>”scripts”</strong> property of your package.json file supports a number of built-in scripts and their preset life cycle events as well as arbitrary scripts. These all can be executed by running <strong>npm run {script_name}</strong>.<br>Let`s see what`s inside the default scripts.<br>•<strong>npx react-native run-android</strong> is one way to run your app - you can also run it directly from within Android Studio.<br>•<strong>npx react-native run-ios</strong> command will automatically run your app on the iOS Simulator by default.<br>•<strong>npx react-native start</strong> – starts Metro Bundler<br>Also you can add your own scripts, here is an example:<br>•<strong>”install:full”</strong>: "rm -rf node_modules && npm install && rm -rf /tmp/metro-bundler-cache-* && cd ./ios && pod install”<br>
          </aside>
        </section>

        <section class="picture-slide">
          <h4 class="slide-name">Project structure recommendations</h4>
          <img src="assets/images/project_st_rec.png" alt="simple" />
          <aside class="notes">
            React Native doesn`t have opinions on how you put files into folders. That said there are a few common approaches popular in the ecosystem you may want to consider.<br><strong>* src</strong>: Contains all major project files.<br><strong>* api</strong>: This folder contains logic related to external API communications.<br><strong>•assets</strong>: This folder will store all the assets that we are using in react-native.<br><strong>•components</strong>: In the components folder, you can create multiple component files that are used to wrap the application components and determine their overall layout. You can also add reusable and UI components.<br><strong>•navigation</strong>: Your project base navigation goes here. You can create a stack navigator in it and export it to your application. <br><strong>* screens</strong>: If you have multiple screens like auth screens: login, register and profile screens, product screens it can be saved here.<br><strong>•store</strong>: If you are using Redux, then there must be action and reducers files that can be put here.<br><strong>* styles</strong>: Here we place the explore feature’s components related styles.<br><strong>* utils</strong>: All the utils/helpers files go here that storing reusable methods and logic like validations, progress bar, date pickers, and according to your app requirements.<br>
          </aside>
        </section>

        <section class="topic-name-slide">
          <h4>Core Components</h4>
        </section>

        <section class="table-slide">
          <h4 class="slide-name">Core Components</h4>
          <table class="fragment" data-fragment-index="2">
            <thead>
              <tr>
                <th>REACT NATIVE UI COMPONENT</th>
                <th>WEB ANALOG</th>
                <th>DESCRIPTION</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>&lt;View&gt;</td>
                <td>A non-scrolling &lt;div&gt;</td>
                <td>Container</td>
              </tr>
              <tr>
                <td>&lt;Text&gt;</td>
                <td>&lt;p&gt;</td>
                <td>Displays, styles, and nests strings of text</td>
              </tr>
              <tr>
                <td>&lt;Image&gt;</td>
                <td>&lt;img&gt;</td>
                <td>Displays different types of images</td>
              </tr>
              <tr>
                <td>&lt;TextInput&gt;</td>
                <td>&lt;input type="text"&gt;</td>
                <td>Allows the user to enter text</td>
              </tr>
              <tr>
                <td>&lt;ScrollView&gt;</td>
                <td>&lt;div&gt;</td>
                <td>A generic scrolling container</td>
              </tr>
            </tbody>
          </table>
          <aside class="notes">
            Components are the building blocks of any React Native application. Components are an abstraction layer on top of the underlying native platform. On an iOS device, a React Native component is ultimately rendered as a UIView. On Android, the same component would be rendered as an android.view.<br>
            <strong>•View:</strong><br>
            The most fundamental component for building a UI, View is a container that supports layout with <strong>flexbox, style, some touch handling</strong>, and <strong>accessibility controls</strong>. View is designed to be nested inside other views and can have 0 to many children of any type.<br>
            <strong>•Text:</strong><br>
            A React component for displaying text. Text supports nesting, styling, and touch handling. (Nested text example). The <strong>Text</strong> element is unique relative to layout: everything inside is no longer using the <strong>Flexbox</strong> layout but using text layout. This means that elements inside of a <strong>Text</strong> are no longer rectangles, but wrap when they see the end of the line.(ContainersExample). Also, you need to know, that <strong>you must wrap all the text nodes inside of a Text component.</strong> You cannot have a text node directly under a View.<br>
            https://reactnative.dev/docs/text<br>
            <strong>•Image:</strong><br>
            A React component for displaying different types of images, including network images, static resources, temporary local images, and images from local disk, such as the camera roll.(https://reactnative.dev/docs/image). Image components has <strong>source prop</strong>. It is the image source (either a remote URL or a local file resource). This prop can also contain several remote URLs, specified together with their width and height and potentially with scale/other URI arguments. The native side will then choose the best uri to display based on the measured size of the image container<br>
            <strong>•TextInput:</strong><br>
            A foundational component for inputting text into the app via a keyboard. Props provide configurability for several features, such as <strong>auto-correction, auto-capitalization, placeholder text, and different keyboard types</strong>, such as a numeric keypad. You can subscribe to the onChangeText events to read the user input. Other important props are the value and the placeholder. value: The value to show for the text input. TextInput is a controlled component, which means the native value will be forced to match this value prop if provided. Placeholder: the string that will be rendered before text input has been entered.<br>
            https://reactnative.dev/docs/textinput<strong>placeholder</strong><br>
              <strong>•ScrollView:</strong><br>Component that wraps platform ScrollView while providing integration with touch locking "responder" system.Keep in mind that ScrollViews must have a bounded height in order to work, since they contain unbounded-height children into a bounded container (via a scroll interaction). In order to bound the height of a ScrollView, either set the height of the view directly (discouraged) or make sure all parent views have bounded height. <br>
          </aside>
        </section>

        <section class="compare-slide">
          <h4 class="slide-name">Flatlist vs map</h4>
          <div>
          <div>
            <img src="assets/images/flat-list.gif" alt="simple" />
            <ul>
              <li>long lists of data</li>
              <li>renders items lazily</li>
            </ul>
          </div>
          <div>
            <img src="assets/images/scroll-view.gif" alt="simple" />
            <ul>
              <li>small number of things of a limited size</li>
              <li>renders all its child components at once</li>
            </ul>
          </div>
        </div>
          <aside class="notes">
            React Native provides a suite of components for presenting lists of data. Generally, there are two methods of listing data in a React Native app: displaying the list with <strong>map</strong> and using the <strong>FlatList</strong> component.<br>The <strong>map</strong> method technically gives you more flexibility to customize your list the way you want with the React Native <strong>ScrollView</strong> component but it loads all the items every time which can be expensive.<br><strong>FlatList</strong> is a React Native component that only loads items that are currently visible on the screen and it deletes items as they go off screen which is more optimal for large amounts of data. Furthermore, it provides scrolling features by default. You don’t need to use extra components like <strong>ScrollView</strong> to make list data scrollable. The FlatList component requires two props: <strong>data</strong> and <strong>renderItem</strong>. data is the source of information for the list. renderItem takes one item from the source and returns a formatted component to render.<br>If you need section support, you can use <strong>SectionList</strong>.<br>
          </aside>
        </section>

        <section class="several-pictures-4-slide-with-description">
          <h4 class="slide-name">Touchables</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/TouchableOpacity.gif" alt="simple" height="350px" width="240px" />
              <p>TouchableOpacity</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/TouchableHighlight.gif" alt="simple" height="350px" width="240px"  />
              <p>TouchableHighlight</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/TouchableWithoutFeedback.gif" alt="simple" height="350px" width="240px"  />
              <p>TouchableWithoutFeedback</p>
            </div>
            <div class="fragment" data-fragment-index="4">
              <img src="assets/images/TouchableNativeFeedback.gif" alt="simple" height="350px" width="240px"  />
              <p>TouchableNativeFeedback</p>
            </div>
          </div>
          <aside class="notes">
            <strong>TouchableHighlight</strong><br>A wrapper for making views respond properly to touches. On press down, the opacity of the wrapped view is decreased, which allows the underlay color to show through, darkening or tinting the view. So, don’t forget to set underlayColor in props. <strong>UnderlayColor</strong> is the color of the underlay that will show through when the touch is active.<br><strong>TouchableOpacity</strong><br>A wrapper for making views respond properly to touches. On press down, the opacity of the wrapped view is decreased, dimming it. You can change the opacity in <strong>activeOpacity</strong> prop.<br><strong>TouchableWithoutFeedback</strong><br>The TouchableWithoutFeedback is used when the user wants to handle press but doesn`t want to see any feedback.TouchableWithoutFeedback supports only one child. If you wish to have several child components, wrap them in a View. Importantly, TouchableWithoutFeedback works by cloning its child and applying responder props to it. It is therefore required that any intermediary components pass through those props to the underlying React Native component.<br><strong>TouchableNativeFeedback</strong><br>A wrapper for making views respond properly to touches (Android only). On Android this component uses native state drawable to display touch feedback.<br>
          </aside>
        </section>

        <section class="topic-name-slide">
          <h4>Styles</h4>
        </section>

        <section class="text-and-conding-slide">
          <h4 class="slide-name">Styles</h4>
          <div class="center-align">
            <p>Constant</p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
							const styles = { fontSize: 30, fontWeight: '600' };
						</code>
					  </pre>
            <p>JavaScript expression inside curly brackets</p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
							style={{ backgroundColor: isUpdated ? 'blue' : 'grey' }}
						</code>
					  </pre>
          </div>
          <aside class="notes">
            With React Native, you style your application using JavaScript. All of the core components accept a prop named <strong>style</strong>. There are multiple ways we can provide value to the <strong>style</strong> prop. React Native use React and it use <strong>JSX</strong> for layout. In JSX you can pass a constant value to props directly or pass javascript expression inside curly brackets. Style prop also accepts array of objects. Even though we can use plain JavaScript objects for style it is not a good practice. What we can do instead is to use the inbuilt StyleSheet API. A StyleSheet is an abstraction similar to CSS StyleSheets. The StyleSheet API has a lot of advantages over the normal object, like compile-time checks, performance improvements and better code auto-completion to name a few.<br>The style names and values usually match how CSS works on the web, except names are written using camel casing, e.g. backgroundColor rather than background-color.<br>If you want to use some features like media-queries or variables you should install <strong>React Native Extended StyleSheet</strong>.<br>
          </aside>
        </section>

        <section class="text-and-conding-slide">
          <h4 class="slide-name">StyleSheet</h4>
          <div class="center-align">
            <p>StyleSheet.create</p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
              const styles = StyleSheet.create({
                title: { fontSize: 30 },
              });              
						</code>
					  </pre>
            <p>StyleSheet.compose</p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
							const styles = StyleSheet.compose(style1.text, style2.bigText);
						</code>
					  </pre>
            <p>StyleSheet.flatten</p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
							const styles = StyleSheet.flatten([style1.text, style2.bigText])
						</code>
					  </pre>
          </div>
          <aside class="notes">
            A StyleSheet is an abstraction similar to CSS StyleSheets.<br><strong>create</strong><br>Creates a StyleSheet style reference from the given object.<br><strong>compose</strong><br>Combines two styles such that style2 will override any styles in style1. If either style is falsy, the other one is returned without allocating an array.<br><strong>flatten</strong><br>Flattens an array of style objects, into one aggregated style object<br>
          </aside>
        </section>

        <section class="picture-slide">
          <h4 class="slide-name">Flex</h4>
          <img src="assets/images/flex.png" alt="simple" />
          <aside class="notes">
            <strong>flex</strong> will define how your items are going to <strong>“fill”</strong> over the available space along your main axis. Space will be divided according to each element`s flex property.<br>
          </aside>
        </section>

        <section class="several-pictures-3-slide-with-description">
          <h4 class="slide-name">FlexGrow, FlexBasis and FlexShrink</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/flexGrow.png" alt="simple" />
              <p>flexGrow</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/flexBasis.png" alt="simple" />
              <p>flexBasis</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/flexShrink.png" alt="simple" />
              <p>flexShrink</p>
            </div>
          </div>
          <aside class="notes">
            * <strong>flexBasis</strong> is an axis-independent way of providing the default size of an item along the main axis. Setting the flexBasis of a child is similar to setting the width of that child if its parent is a container with flexDirection: row or setting the height of a child if its parent is a container with flexDirection: column. The flexBasis of an item is the default size of that item, the size of the item before any flexGrow and flexShrink calculations are performed.<br>* <strong>flexGrow</strong> describes how any space within a container should be distributed among its children along the main axis. After laying out its children, a container will distribute any remaining space according to the flex grow values specified by its children.<br>
          </aside>
        </section>

        <section class="several-pictures-4-slide-with-description">
          <h4 class="slide-name">Flex Direction</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/flexDirection-column.png" alt="simple" />
              <p>column</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/flexDirection-row.png" alt="simple" />
              <p>row</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/flexDirection-rr.png" alt="simple" />
              <p>row-reverse</p>
            </div>
            <div class="fragment" data-fragment-index="4">
              <img src="assets/images/flexDirection-cr.png" alt="simple" />
              <p>column-reverse</p>
            </div>
          </div>
          <aside class="notes">
            <strong>flexDirection</strong> controls the direction in which the children of a node are laid out. This is also referred to as the main axis. The cross axis is the axis perpendicular to the main axis, or the axis which the wrapping lines are laid out in.<br>* <strong>column (default value)</strong> Align children from top to bottom. If wrapping is enabled, then the next line will start to the right of the first item on the top of the container.<br>* <strong>row</strong> Align children from left to right. If wrapping is enabled, then the next line will start under the first item on the left of the container.<br>* <strong>column-reverse</strong> Align children from bottom to top. If wrapping is enabled, then the next line will start to the right of the first item on the bottom of the container.<br>* <strong>row-reverse</strong> Align children from right to left. If wrapping is enabled, then the next line will start under the first item on the right of the container.<br>
          </aside>
        </section>

        <section class="several-pictures-3-slide-with-description">
          <h4 class="slide-name">Justify Content</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/justifyContent-fs.png" alt="simple" />
              <p>flex-start</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/justifyContent-center.png" alt="simple" />
              <p>center</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/justifyContent-fe.png" alt="simple" />
              <p>flex-end</p>
            </div>
          </div>
          <aside class="notes">
            <strong>justifyContent</strong> describes how to align children within the main axis of their container. For example, you can use this property to center a child horizontally within a container with flexDirection set to row or vertically within a container with flexDirection set to column.<br>•\t<strong>flex-start(default value)</strong> Align children of a container to the start of the container`s main axis.<br>* <strong>flex-end</strong> Align children of a container to the end of the container`s main axis.<br>* <strong>center</strong> Align children of a container in the center of the container`s main axis.<br>
          </aside>
        </section>

        <section class="several-pictures-3-slide-with-description">
          <h4 class="slide-name">Justify Content</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/justifyContent-sb.png" alt="simple" />
              <p>space-between</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/justifyContent-sa.png" alt="simple" />
              <p>space-around</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/justifyContent-se.png" alt="simple" />
              <p>space-evenly</p>
            </div>
          </div>
          <aside class="notes">
            * <strong>space-between</strong> Evenly space off children across the container`s main axis, distributing the remaining space between the children.<br>* <strong>space-around</strong> Evenly space off children across the container`s main axis, distributing the remaining space around the children. Compared to space-between, using space-around will result in space being distributed to the beginning of the first child and end of the last child.<br>* <strong>space-evenly</strong> Evenly distribute children within the alignment container along the main axis. The spacing between each pair of adjacent items, the main-start edge and the first item, and the main-end edge and the last item, are all exactly the same.<br>
          </aside>
        </section>

        <section class="several-pictures-3-slide-with-description">
          <h4 class="slide-name">Align Items</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/alignItems-sfb.png" alt="simple" />
              <p>stretch,
                flex-start,
                baseline
                </p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/alignItems-center.png" alt="simple" />
              <p>center</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/alignItems-fe.png" alt="simple" />
              <p>flex-end</p>
            </div>
          </div>
          <aside class="notes">
            <strong>alignItems</strong> describes how to align children along the cross axis of their container. It is very similar to justifyContent but instead of applying to the main axis, alignItems applies to the cross axis.<br>* <strong>stretch (default value)</strong> Stretch children of a container to match the height of the container`s cross axis.<br>* <strong>flex-start</strong> Align children of a container to the start of the container`s cross axis.<br>* <strong>flex-end</strong> Align children of a container to the end of the container`s cross axis.<br>* <strong>center</strong> Align children of a container in the center of the container`s cross axis.<br>* <strong>baseline</strong> Align children of a container along a common baseline. Individual children can be set to be the reference baseline for their parents.<br>
          </aside>
        </section>

        <section class="several-pictures-3-slide-with-description">
          <h4 class="slide-name">Align Content</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/alignContent-fs.png" alt="simple" />
              <p>flex-start</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/alignContent-center.png" alt="simple" />
              <p>center</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/alignContent-fe.png" alt="simple" />
              <p>flex-end</p>
            </div>
          </div>
          <aside class="notes">
            <strong>alignContent</strong> defines the distribution of lines along the cross-axis. This only has effect when items are wrapped to multiple lines using flexWrap.<br>* <strong>flex-start (default value)</strong> Align wrapped lines to the start of the container`s cross axis.<br>* <strong>flex-end</strong> Align wrapped lines to the end of the container`s cross axis.<br>* <strong>stretch</strong> (default value when using Yoga on the web) Stretch wrapped lines to match the height of the container`s cross axis.<br>
          </aside>
        </section>

        <section class="several-pictures-3-slide-with-description">
          <h4 class="slide-name">Align Content</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/alignContent-stretch.png" alt="simple" />
              <p>stretch</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/alignContent-sb.png" alt="simple" />
              <p>space-between</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/alignContent-sa.png" alt="simple" />
              <p>space-around</p>
            </div>
          </div>
          <aside class="notes">
            * <strong>center</strong> Align wrapped lines in the center of the container`s cross axis.<br>* <strong>space-between</strong> Evenly space wrapped lines across the container`s cross axis, distributing the remaining space between the lines.<br>* <strong>space-around</strong> Evenly space wrapped lines across the container`s cross axis, distributing the remaining space around the lines. Compared to space-between, using space-around will result in space being distributed to the beginning of the first line and the end of the last line.<br>
          </aside>
        </section>

        <section class="several-pictures-4-slide-with-description">
          <h4 class="slide-name">Align Self</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/alignSelf-stretch.png" alt="simple" />
              <p>stretch</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/alignSelf-fsb.png" alt="simple" />
              <p>flex-start, baseline</p>
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/alignSelf-center.png" alt="simple" />
              <p>flex-end</p>
            </div>
            <div class="fragment" data-fragment-index="4">
              <img src="assets/images/alignSelf-fe.png" alt="simple" />
              <p>center</p>
            </div>
          </div>
          <aside class="notes">
            <strong>alignSelf</strong> has the same options and effect as alignItems but instead of affecting the children within a container, you can apply this property to a single child to change its alignment within its parent. alignSelf overrides any option set by the parent with alignItems.<br>
          </aside>
        </section>

        <section class="several-pictures-2-slide-with-description">
          <h4 class="slide-name">Flex Wrap</h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/flexwrap_wrap.png" alt="simple" />
              <p>wrap</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/flexwrap_nowrap.png" alt="simple" />
              <p>nowrap</p>
            </div>
          </div>
          <aside class="notes">
            The <strong>flexWrap</strong> property is set on containers and it controls what happens when children overflow the size of the container along the main axis. By default, children are forced into a single line (which can shrink elements). If wrapping is allowed, items are wrapped into multiple lines along the main axis if needed.<br>When wrapping lines, alignContent can be used to specify how the lines are placed in the container.<br>
          </aside>
        </section>

        <section class="text-and-conding-slide">
          <h4 class="slide-name">Platform Specific Code</h4>
          <div class="center-align">
            <p>Platform.OS</p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
              if(Platform.OS === 'ios') {}           
						</code>
					  </pre>
            <p>Platform.Version</p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
              if(Platform.Version === 25) {}   
						</code>
					  </pre>
            <p>Platform.select</p>
            <pre data-id="code-animation">
						<code class="js" data-trim data-line-numbers>
              const Component = Platform.select({
                ios: () => require('ComponentIOS'),
                android: () => require('ComponentAndroid'),
              });
						</code>
					  </pre>
          </div>
          <aside class="notes">
            Sometimes you may want to implement separate visual components for Android and iOS.<br>* <strong>The Platform API</strong> allows us to conditionally apply different styles or properties in our component based on the device’s operating system.<br>*  The OS attribute of the object returns either iOS or android depending on the user’s device. <br>•There is also a Platform.select method available, that given an object where keys can be one of `ios` | `android` | `native` | `default`, returns the most fitting value for the platform you are currently running on.<br>•The Platform module can also be used to detect the version of the Android Platform or system version of iOS<br>
          </aside>
        </section>

        <section class="picture-slide">
          <h4 class="slide-name">Platform Specific extensions</h4>
          <img src="assets/images/extensions.png" alt="simple" />
          <aside class="notes">
            <strong>Platform-specific extensions</strong><br>•When your platform-specific code is more complex, you should consider splitting the code out into separate files. React Native will detect when a file has a .ios. or .android. extension and load the relevant platform file when required from other components.<br>•You can also use the .native.js extension when a module needs to be shared between NodeJS/Web and React Native but it has no Android/iOS differences.<br>
          </aside>  
        </section>

        <section class="topic-name-slide">
          <h4>Architecture</h4>
        </section>

        <section class="picture-slide-grouped">
          <h4 class="slide-name">Old architecture</h4>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/ao_1.png" alt="simple" />
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/ao_2.png" alt="simple" />
            </div>
          <aside class="notes">
            when you look at the react native architecture you should imagine two different worlds — one is the native and another is the JavaScript. This two worlds communicate with each other via <strong>React Native bridge</strong>. React Native parses the bunch of commands coming from the React world into a JSON array, serializes it as a string, and then transfers it to the native world via that bridge. To maintain consistency across all platforms, React Native implements the actual layout by converting React-based display styles (eg, flex) to the relative position values where each element is to be structured and then finally passes it over the UI layer of the native world.<br>
          </aside>
        </section>

        <section class="picture-slide-grouped">
          <h4 class="slide-name">Old architecture</h4>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/arc_old_1.png" alt="simple" />
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/arc_old_2.png" alt="simple" />
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/arc_old_3.png" alt="simple" />
            </div>
            <div class="fragment" data-fragment-index="4">
              <img src="assets/images/arc_old_4.png" alt="simple" />
            </div>
            <div class="fragment" data-fragment-index="5">
              <img src="assets/images/arc_old_5.png" alt="simple" />
            </div>
            <div class="fragment" data-fragment-index="6">
              <img src="assets/images/arc_old_6.png" alt="simple" />
            </div>
          <aside class="notes">
            Broadly speaking, the current React Native architecture is based on 3 major threads.<br>* <strong>Main/Native/UI thread</strong> — where all the UI elements are rendered and native code is executed.<br>* <strong>JavaScript thread</strong> — this thread is responsible for executing and compiling all the JavaScript-related code.<br>* <strong>Layout thread/Shadow Thread</strong> —  is a background thread where the actual layout is calculated. It recasts the flexbox layout with the help of Facebook’s layout engine called <strong>Yoga.</strong><br>
          </aside>
        </section>

        <section class="picture-slide-grouped">
          <h4 class="slide-name">New architecture</h4>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/arc_new_1.png" alt="simple" />
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/arc_new_2.png" alt="simple" />
            </div>
            <div class="fragment" data-fragment-index="3">
              <img src="assets/images/arc_new_3.png" alt="simple" />
            </div>
          <aside class="notes">
            In new architecture we can see familiar threads: <strong>UI, JavaScript and Shadow.</strong><br>But, the React Native re-architecture will progressively see the deprecation of the bridge in favor of a new element called the JavaScript Interface <strong>(JSI)</strong>. An enabler for <strong>Fabric</strong> and <strong>TurboModules</strong>.<br>The JSI allows for a few exciting improvements, the JSC engine can now easily be swapped with other — potentially more performant.<br>The second improvement is the foundation of this new architecture: "By using JSI, JavaScript can hold reference to C++ Host Objects and invoke methods on them. JavaScript and Native realms will be truly aware of each other.”<br>In other terms, JSI would allow for complete interoperability between all threads. With the concept of shared ownership, the JavaScript code could communicate with the native side <strong>directly</strong> from the JS thread, and there won’t be any need to serialize to JSON the messages to pass across, <strong>removing all congestion and asynchronous issues on the bridge.</strong><br>In addition to improving considerably the communication between the different threads, this new architecture also allows for direct control over our native modules. Meaning that we can <strong>use native modules when we need them, as opposed to loading them all once at startup.</strong> This results in massive performance improvements of startup times.<br>
          </aside>
        </section>

        <section class="topic-name-slide">
          <h4>Code Quality Tools</h4>
        </section>

        <section class="several-pictures-2-slide-with-description">
          <h4 class="slide-name">ESLint & Prettier </h4>
          <div>
            <div class="fragment" data-fragment-index="1">
              <img src="assets/images/eslint.png" alt="simple" />
              <p>For catching errors</p>
            </div>
            <div class="fragment" data-fragment-index="2">
              <img src="assets/images/prettier.png" alt="simple" />
              <p>For formatting</p>
            </div>
          </div>
          <aside class="notes">
            <strong>ESLint</strong> is a JavaScript linting utility that was first released in June 2013 and now is by far the number one linting utility. Linting is a type of static analysis that finds problematic patterns and code that doesn’t adhere to certain style guidelines.However, ESLint enables developers to discover problems with their code without actually executing their code.The primary reason ESLint was created was to allow developers to create their own linting rules. ESLint has built-in rules that make it useful from the start, but you can add rules specific to your project and whatever flavor of JavaScript you use.<br><strong>Prettier</strong> is an opinionated code formatter for JavaScript and other popular languages. Prettier enforces a consistent format by parsing code and reprinting it with its own rules that take the maximum line length into account, wrapping code when necessary.<br>This rewriting process prevents developers from introducing any formatting mistakes.<br>
          </aside>
        </section>

        <section class="text-and-frame-slide">
          <h4 class="slide-name">Husky</h4>
          <img src="assets/images/husky.png" alt="simple" />
          <div>
            <p>Setup:</p>
            <div class="frame">
              <code class="js" data-trim data-line-numbers>
                npm install husky --save-dev
              </code>
            </div>
            <p>In your package.json file:</p>
            <div class="frame">
              <code class="js" data-trim data-line-numbers>
                "scripts" {
                  "test": "karma start",
                  "lint": "npm run tslint \"Client/**/*.ts\"",
                  "precommit": "npm run lint && npm test",
                  "prepush": "npm run lint"
              }              
              </code>
            </div>
          </div>
          <aside class="notes">
            <strong>Husky</strong><br>Husky is a very popular (1 million downloads a month) npm package that allows custom scripts to be ran against your repository. Husky works with any project that uses a package.json file. It also works out of the box with SourceTree!Any time you try and commit, the hooks will run your lint command first. The hooks will not allow your commit to pass if the lint or tests are failing.<br>
          </aside>
        </section>        

        <section class="qa-slide">
          <h4>QA</h4>
        </section>
      </div>
    </div>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/dist/reveal.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/zoom/zoom.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/notes/notes.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/search/search.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/markdown/markdown.js"></script>
    <script src="https://rolling-scopes-school.github.io/react-native-course/reveal-js/plugin/highlight/highlight.js"></script>
    <script>
      var url = new URL(window.location.href);
      var showNotes = url.searchParams.has("showNotes");

      if (showNotes) {
        var head = document.getElementsByTagName("HEAD")[0];
        var link = document.createElement("link");
        link.rel = "stylesheet";
        link.type = "text/css";
        // USE THIS IN YOUR PRESENTATION
        // link.href = "https://rolling-scopes-school.github.io/react-native-course/reveal-js/speaker-notes-mobile.css";
        link.href = "../reveal-js/speaker-notes-mobile.css";
        head.appendChild(link);
      }

      Reveal.initialize({
        disableLayout: true,
        controls: true,
        progress: true,
        center: false,
        hash: true,
        autoPlayMedia: true,
        showNotes,
        plugins: [
          RevealZoom,
          RevealNotes,
          RevealSearch,
          RevealMarkdown,
          RevealHighlight,
        ],
      });
    </script>
  </body>
</html>
